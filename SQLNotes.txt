			Typing word -- the quick brown fox jumps over the little lazy dog.

Mysql --> pwd=password
1)show databases
2)create database ntsp715; 
3)use ntsp715;

CONNECT SYS AS SYSDBA
Enter password: SYS_password 

unname& pwd=lone  Oracle DB
First use connection as sysdba --: command / as sysdba in SqlPlus

1) alter session set "_oracle_script"=true;

2) SQL Plus --> create user ntsp715 identified by ntsp
3) grant all privileges to ntsp715

select * from dba_users where username='ntsp715'

1) SELECT * FROM all_users;
--> Display all users of database

2) SELECT table_name FROM user_tables;
 get all tables created by users

3)  SELECT empno,ename,
         SUBSTR(LOWER(ename),1,3)||SUBSTR(empno,1,3)||'@oracle.com' as emailid
  FROM emp ;


Change Drive Like C To D ( cd..Enter D:Enter cd NareshIT enter)

                           ORACLE

          DEVELOPER                   DBA 
          								set pagesize 2000;
          creating tables           installation of oracle 		set linesize 2000;
          creating views            creating database
          creating synonyms         creating userids & pwds	
          creating indexes          db backup & restore		
          creating procedures       db export & import						
          creating functions        db upgradation & migration					    
          creating packages         db mirroring & replication0+3

          creating triggers         performance tuning
          writing queries 

 
  Database :- 

  => a Database is a organized collectin of interrelated data.
     For ex a univercity db stores data related to students,courses,
     faculty etc.

 Types of Databases :- 

 1 OLTP (online transaction processing)
 2 OLAP (online analytical processing) / DWH / DSS

        DWH => Data Warehouse
        DSS => Decision support system

 => organizations uses OLTP for storing day-to-day transactions  	
 and OLAP for data analysis.

 => OLTP is used for running business and OLAP is used for to analyze
  business.

=> day-to-day operations on db includes 

  C => create
  R => read
  U => update
  D => delete

 DBMS :- 
 
 => DBMS stands for database management system
 => DBMS is a software used to create and to manage database.
  => software used for DB development and administration.

 Evolution of DBMS :-  


   1960		 FMS (file mgmt system)

   1970		 HDBMS (hierarchical dbms)
		 NDBMS (network dbms)

   1980		 RDBMS (relational dbms)

   1990		 ORDBMS (object relational dbms)
		 OODBMS (object oriented dbms)


  RDBMS :-   (Relational Database Management System)

  => according to rdbms in db data must be organized in tables 
     i.e. rows and columns .

   CUSTOMERS
   CID	CNAME	CADDR
   10	VIJAY	HYD
   11	SACHIN	MUM
   12	ROHIT	DEL

         Database =  collection of tables
         Table    =  collection of rows & cols
         Row      =  collection of field values
         Column   =  collection of values assigned to one field

 => according to RDBMS every table must contain a primary key 
   to uniquely identify records.

   
    EX :- ACCNO,EMPID,AADHARNO,CID,PANNO

 => one table is related to another table using foreign key.

 RDBMS features :- 

 1 easy to access(R) and manipulate(c,u,d) data 
 2 less redundency(duplication)
 3 more security
 4 gurantess data integrity(i.e. data quality or data consistency).
 5 supports data sharing
 6 supports transactions  


 RDBMS softwares :- (SQL databases)

 ORACLE            from oracle corp
 SQL SERVER        from Microsoft
 DB2               from IBM
 TERADATA          from NCR 
 MYSQL             from oracle corp (open source)
 POSTGRESQL        open source
 
 
  NoSQL Databases :- 

  1 mongoDB
  2 cassandra 
 
  ORDBMS :- (object relational dbms)

  => ORDBMS is combination of RDBMS and OOPS 

         ORDBMS = RDBMS + OOPS(reusability)
 
 => RDBMS doesn't support reusability but ORDBMS supports reusability
 => ORDBMS supports reusability by using ADT (abstract datatype).

 RDBMS :- 

  EMP
  EMPID  ENAME  HNO  STREET  CITY  STATE  PIN

  CUST
  CID    CNAME  HNO  STREET  CITY  STATE  PIN
 
      
 ORDBMS :- 

        ADT :- ADDR(HNO,STREET,CITY,STATE,PIN)

        EMP
        EMPID  ENAME   ADDR

        CUST
        CID    CNAME   ADDR


 ORDBMS softwares :- 

  ORACLE upto 7ver RDBMS 
  ORACLE from 8ver ORDBMS 
 
 
----------------------------------------------------------------------

 			ORACLE 12c/19C

 => It is basically a RDBMS product from Oracle corp and also supports 
   features of ORDBMS and  used for db development and administration.

   design                development       administration

   ER model		 ORACLE 12C/19C    ORACLE 12C/19C
   Normalization
				
 versions of ORACLE :- 
 
 Version  	   Year	             New Features

Oracle v2,         1979		First commercially SQL-based RDBMS
Oracle v3,         1983		Concurrency control, data distribution, scalability
Oracle v4,         1984		Multiversion read consistency
Oracle v5,         1985	 	Client/server computing Support & distributed database systems
Oracle v6,         1988		Row-level locking, scalability, online backup and recovery, PL/SQL, Oracle Parallel Server
Oracle  7,         1992		PL/SQL stored procedures, Triggers, Shared Cursors, Cost Based Optimizer, Transparent Application Failover
Oracle  8i,        1997		Recovery Manager, Partitioning, Dataguard, Native internet protocols, Java, Virtual Private Database
Oracle  9i,        2001		Oracle Real Application Clusters (RAC), Oracle XML DB, Data Mining, Streams, Logical Standby
Oracle 10gR1,  	 2003		Grid infrastructure, Oracle ASM, Flashback Database, Automatic Database Diagnostic Monitor
Oracle 10gR2,      2005		Real Application Testing, Database Vault, Online Indexing, Advanced Compression, Transparent Data Encryption
Oracle 11gR1,      2007		Active Data Guard, Secure Files, Exadata
Oracle 11gR2,      2009		Data Redaction, Hybrid Columnar Compression, Cluster File System, Golden Gate Replication, Database Appliance
Oracle 12cR1,      2013		Multitenant architecture, In-Memory Column Store, Native JSON, SQL Pattern Matching, Database Cloud Service
Oracle 12cR2,      2016		Native Sharding, Zero Data Loss Recovery Appliance, Exadata Cloud Service, Cloud at Customer
Oracle 18c,        2018		Autonomous Database, Data Guard Multi-Instance Redo Apply, Polymorphic Table Functions, Active Directory Integration
Oracle 19c         2019		Automatic Indexing, Data-guard DML Redirect,Partitioned Hybrid Tables, Real-time Stats + Stats Only Queries

        i => internet
        g => grid
        c => cloud

 => from ver 8 onwards oracle supports internet applications.

 => GRID means collection of servers, from 10g onwards oracle db
  can be accessed through multiple servers. Grid improves availability

 => from 12c onwards oracle supports

  1 on premises deployment
  2 on cloud  deployment

 => in " on premises " db is deployed in server managed by client
 
 => in " on cloud " db is deployed in server managed by cloud
 service providers like amazon,microsoft etc.
 
 
 => after installing ORACLE 12C/19C the following components are
    created in our system

 
  1 SERVER
  2 CLIENT

 SERVER :- 

 => server is a system where oracle software is installed and running

 => inside the server oracle manages two memories 

   1 DB
   2 INSTANCE

 => DB is created in hard disk and acts as permanent storage

 => INSTANCE is created in RAM and acts as temporary storage

 CLIENT :- 

 => using client system users can 

  1 connects to server
  2 submit requests to server
  3 recieves response from server

 client tools :- 

 1 SQLPLUS
 2 SQL DEVELOPER
 3 TOAD

 
  			   SQL 
                           ---

   => SQL stands for structured query language.
   => It is a language used to communicate with oracle.
   => user communicates with oracle by sending commands called queries.
   => SQL is originally introduced by IBM and initial name of this
      language was "SEQUEL" and later it is renamed to SQL. 
   => SQL is common to all relational databases.

      ORACLE     SQL SERVER   DB2   MYSQL   POSTGRESQL
         SQL         SQL       SQL   SQL       SQL
     
    => based on operations over db SQL is categorized into following 
 sublanguages.

       DDL (DATA DEFINITION LANG)
       DML (DATA MANIPULATION LANG)  --> commit is required
       DQL (DATA QUERY LANG)
       TCL (TRANSACTION CONTROL LANG)
       DCL (DATA CONTROL LANG)

                          SQL
 
        DDL       DML      DQL      DCL        TCL

       create    insert   select   commit     grant
       alter     update            rollback   revoke
       drop      delete            savepoint
       truncate  insert all
       rename    merge
       flashback
       purge


    EMPID ENAME  SAL    DATA DEFINITION   lone_santosh Atish67@    FB 8605477468 Acelya@#1122
      1   A      6000   DATA 		lonesanos183@gmal.com	Atish67@#	nokri - Lon1122@#				

  
   schema :- 

   => a user in oracle db is called schema 
   => objects created by user are called schema objects 
   
  server
     database
         users 
            tables
               data 

 
   SERVER                     DBA => DB Administrator
      ORCL
        SYS(DBA)
        SYSTEM/MANAGER(DBA)
        SCOTT/TIGER(normal)
        HR/HR (normal)

   how to connect to oracle :-
   --------------------------

  => to connect to oracle open sqlplus and enter username & pwd

       USERNAME    :- SYSTEM
       PASSWORD    :- TIGER
   
 
       USERNAME  :-  SYSTEM/MANAGER

  how to connect to sys :- 

       USERNAME :-  / AS SYSDBA 

  creating user/schema/account in oracle db :- 

  => only DBA has got permissions to create new users.

  step 1 :- connect to oracle as SYSTEM/MANAGER

  step 2 :- create user

     syntax :-  CREATE USER <NAME> IDENTIFIED BY <PWD>
                DEFAULT TABLESPACE USERS
                QUOTA UNLIMITED ON USERS ;

     Example :- 

            SQL>CREATE USER BATCH7AM IDENTIFIED BY NARESH
                DEFAULT TABLESPACE USERS
                QUOTA UNLIMITED ON USERS ;

  step 3 :-   granting permissions to user

            SQL>GRANT CONNECT,RESOURCE TO BATCH7AM ;

                    CONNECT  => to connect to db
                    RESOURCE => to create tables
                    DBA      => all permissions 

  changing password :- 
 
  => both  user & DBA can change password. 

  by user :- (BATCH7AM/NARESH) 

  SQL>PASSWORD
   old password          :- NARESH
   new password          :- TIGER
   retype new password   :- TIGER
   password changed

  by DBA :- (SYSTEM/TIGER) 

  SQL>ALTER USER BATCH7AM IDENTIFIED BY ORACLE ; 

  how to change dba (system) password :- 

 
  step 1 :-  conn as SYS

          USERNAME :- / AS SYSDBA

  step 2 :- 

        SQL>ALTER USER SYSTEM IDENTIFIED BY MANAGER; --> my db pwd is  system/manager


  Datatypes in ORACLE :- 
  ---------------------

 => datatype specifies 

  1 type of the data allowed in a column
  2 amount of memory allocated for column
  
		        Datatypes

    CHAR	        Numeric          DATE          BINARY

	       		Number(p)        DATE          BFILE
ASCCI     UNICODE       Number(p,s)      TIMESTAMP     BLOB
char	  nchar
varchar2  nvarchar2
long	  nclob
clob
    

char(size) :- 

 => allows character data upto 2000 chars.
 => recommended for fixed length char columns.
 
   ex :-  NAME    CHAR(10)
          
          sachin----
                  wasted
          
          rohit-----
                  wasted 

  => in char datatype extra bytes are wasted , so don't use char
 for variable length fields and use char for fixed length fields.

      ex :-   state_code   char(2)
              
              AP
              MH
              UP
        
             country_code  char(3) 

             IND
             USA
             JPN

 VARCHAR2 :-  

 => allows charactere data upto 4000 chars.
 => VARCHAR2 is recommended for variable length fields.
 => in VARCHAR2 extra bytes are released.
 
  ex :-   NAME   VARCHAR2(10)

          sachin----
                  released

          rohit-----
                 released

 => both char,varchar2 allows ASCII chars(256 chars) that includes
    a-z,A-Z,0-9,special chars.

             VEHNO        CHAR(10)

             TS09EF1234
            
             PANNO       CHAR(10)
 
                 
  LONG :- 

  => allows character data upto 2GB.

       FEEDBACK   LONG

 CLOB :- (character large object)

  => allows character data upto 4GB.

 NCHAR/NVARCHAR2/NCLOB :-  (N => National) 

 => allows unicode characters (65536 chars) that includes all
  ascii chars and characters belongs to different languages.
  
 Number(p) :- 

 => allows numeric data upto 38 digits 
 => allows exact numbers i.e. numbers that doesn't contain decimal part
 
   ex :-  empid  Number(4)
 
          10
          100
          1000
          10000 => invalid

 Number(p,s) :- 

  => allows approximate numbers i.e. numbers contains decimal part.

    p  => precision  => total no of digits allowed
    s  => scale      => no of digits allowed after decimal

      ex :-  Salary   Number(7,2) 
             
             5000
             5000.50
            50000.50 
           500000.50 => not allowed 

             5000.507   => allowed => 5000.51
             5000.503   => allowed => 5000.50
 
   DATE :- 

   => allows date & time 
   => time is optional , if not entered then oracle stores 12:00AM
   => default date format in ORACLE is DD-MON-YY/YYYY

       ex :-    DOB    DATE 
                
                18-DEC-20    =>  18-DEC-2020 
                10-MAR-95    =>  10-MAR-2095
                10-MAR-1995  =>  10-MAR-1995
      
 from 9i :-
    
   TIMESTAMP :- 

   => timestamp allows date,time and also milliseconds 

       ex :-  T    TIMESTAMP

              30-DEC-20 7:51:20.123
              --------- ------  ---
                  DATE   TIME   MS

  INTERVAL YEAR TO MONTH :- 

  => used for storing time intervals in years and months 

          DURATION     INTERVAL YEAR TO MONTH

          INTERVAL '5' YEAR
          INTERVAL '5-6' YEAR TO MONTH
          INTERVAL '6' MONTH

  INTERVAL DAY TO SECOND :- 

 => used for storing time intervals in days,hours,minutes and seconds

           DURATION   INTERVAL DAY TO SECOND
           
           INTERVAL '10 3' INTERVAL DAY TO HOUR
           INTERVAL '15 3:30' INTERVAL DAY TO MINUTE
           INTERVAL '5 2:30:20' INTERVAL DAY TO SECOND
     

  Binary Types :- 

  => allows binary data that includes audio,video,images
  => oracle supports 2 binary types

  1 BFILE (binary file)
  2 BLOB  (binary large object) 

  => BFILE is external lob because lob is stored outside db but 
 db stores path.

 => BLOB is called internal lob because lob stored inside db.

 
 CREATING TABLES IN ORACLE DB :- 

 CREATE TABLE <TABNAME>
 (
   COLNAME DATATYPE(SIZE),
   COLNAME DATATYPE(SIZE),
   ------------------
  );

 Rules :- 

 1 tabname should start with alphabet
 2 tabname should not contain spaces and special chars but allows _,$,#
 3 tabname can be upto 128 chars
 4 table can have upto 1000 columns
 5 no of rows unlimited.

    EMP123     VALID
    123EMP     INVALID
    EMP 123    INVALID
    EMP*123    INVALID
    EMP_123    VALID
 

 Example :- 

 create EMP table with following structure ?

 EMP
 EMPID  ENAME  AGE  JOB  SAL  HIREDATE  

 CREATE TABLE emp
 (
   empid     NUMBER(4),
   ename     VARCHAR2(10),
   age       NUMBER(2),
   job       VARCHAR2(10),
   sal       NUMBER(7,2),
   hiredate  DATE
  );

  => above command created table structure/definition/metadata 
 that includes columns,datatype and size.

 DESC :-  (DESCRIBE)

 => command used to see the structure of the table.

        syn :- DESC <tabname>

    SQL>DESC EMP ;

      EMPID     NUMBER(4),
      ENAME     VARCHAR2(10),
      AGE       NUMBER(2),
      JOB       VARCHAR2(10),
      SAL       NUMBER(7,2),
      HIREDATE  DATE

 INSERTING DATA INTO TABLE :- 

 => use "INSERT" command to insert data into table. 
 => using INSERT we can insert 

  1 single row
  2 multiple rows

 INSERTING SINGLE ROW :- 

 syn :- INSERT INTO <TABNAME> VALUES(V1,V2,V3,---------);

 Ex :- 

 SQL>INSERT INTO EMP VALUES(100,'sachin',40,'clerk',4000,'01-JAN-20');
 SQL>INSERT INTO EMP VALUES(101,'rohit',30,'manager',8000,sysdate);

 INSERTING MULTIPLE ROWS :- 

 => we can execute INSERT command multiple times with different values
  by using variables prefixed with "&".

  syn :- INSERT INTO <TABNAME> VALUES(&F1,&F2,&F3,------)

 Ex :- SQL>INSERT INTO EMP 
                 VALUES(&EMPID,&ENAME,&AGE,&JOB,&SAL,&HIREDATE);
           
           enter value for empid :- 102
                           ename :- 'vijay'
                           age   :- 30
                           job   :- 'analyst'
                           sal   :- 6000
                       hiredate  :- 10-OCT-19

        1 row created

        SQL> /  (previous command is reexecuted)

            enter value for empid :- 103
                        

                         hiredate :- sysdate
 
          1 row created
   
  INSERTING NULLS :- 

  => a null means blank or empty
  => it is not equal to 0 or space
  => NULLs can be inserted in two ways 

   method 1 :- (Explicit)

   INSERT INTO EMP VALUES(104,'ajay',30,'',NULL,sysdate);

   method 2 :- (Implicit)

   INSERT INTO EMP(EMPID,ENAME,AGE,HIREDATE) 
                VALUES(105,'phani',40,'12-MAR-19');

   remaining two fields automatically filled with NULLs.

  Displaying Data :- 

  => use "SELECT" command to display data from db table/tables
  => we can display all rows and all columns or specific rows and specific columns

        SELECT columns/* FROM tabname

         SQL     =  ENGLISH        
         Queries =  sentences  
         clauses =  words
  
         FROM   => specify tablename
        SELECT  => specify column names
            *   => all columns 

        display employee names and salaries ? 

        SELECT ename,sal FROM emp; 
        
        display all the data from emp ? 

        SELECT * FROM emp ;

 Operators in ORACLE :- 
 
 Arithmetic Operators =>   +  -  *   /
 Relational Operators =>   >  >=  <   <=   =   <> 
 Logical Operators    =>   AND  OR  NOT
 Special Operators    =>   BETWEEN
                           IN
                           LIKE
                           IS 
                           ANY
                           ALL
                           EXISTS
                           PIVOT & UNPIVOT
 Set Operators        =>   UNION
                           UNION ALL
                           INTERSECT
                           MINUS

 WHERE clause :- 

 => used to get specific row/rows from table based on a condition

     SELECT columns/*
     FROM tabname
     WHERE condition ;

 condition :- 

             COLNAME  OP  VALUE

 
  => OP must be any relational or special operator
  => if condition evaluates to true then row is selected
  => if condition evaluates to false then row is not selected

 
  Display employee details whose empid=104 ? 

  SELECT * FROM emp WHERE empid=104 ;

  Display employee details whose name=rohit? 

  SELECT * FROM emp WHERE ename='rohit' ;
 
  SELECT * FROM emp WHERE ename='ROHIT'; => no rows selected 

  note :- in oracle string comparision is case sensitive i.e. 
  uppercase and lowecase strings are not same.

  Display employee details whose age > 30 ? 

  SELECT * FROM emp WHERE age > 30 ;
 
  Display employee details joined after 2019 ?

  SELECT * FROM emp WHERE hiredate > 2019 ; => ERROR

  SELECT * FROM emp WHERE hiredate > '31-DEC-2019' ;

  Display employee joined before 2020 ?

  SELECT * FROM emp WHERE hiredate < '01-JAN-2020' ;

 compound condition :- 

 => multiple conditions combined with AND/OR operators is called
 compound condition.

           COND1   AND    COND2    RESULT
           T              T         T            
           T              F         F  
           F              T         F
           F              F         F


           COND1  OR  COND2    RESULT
            T         T         T
            T         F         T
            F         T         T
            F         F         F

 
    display employee list working as clerk,manager ?

    SELECT * FROM emp WHERE job='clerk','manager' ; => invalid

    SELECT * FROM emp WHERE job='clerk' or 'manager'; => invalid

    SELECT * FROM emp WHERE job='clerk' OR job='manager' ; => valid

    SELECT * FROM emp WHERE job='clerk' AND job='manager' ; => no rows

    display employees whose empid = 100,103,105 ? 

    SELECT * FROM emp WHERE empid=100 OR empid=103 OR empid=105 ;
  
    
 IN operator :- 

  => use IN operator when "="  comparision with list of values.

        WHERE COL = V1,V2,V3,--   => INVALID         
        WHERE COL IN (V1,V2,V3,--) => VALID  (COL=V1 OR COL=V2 OR COL=V3)
        WHERE COL NOT IN (V1,V2,V3,--)

  => display employees working as clerk,manager ?

     SELECT * FROM emp WHERE job IN ('clerk','manager') 
        
  => display employees whose empid=100,103,105 ?

     SELECT * FROM emp WHERE empid IN (100,103,105) ;

  => display employees not working as clerk,manager ? 

     SELECT * FROM emp WHERE job NOT IN ('clerk','manager'); 

  => display employees working as clerk,manager and earning more than 5000 ?

    SELECT * 
    FROM emp
    WHERE job IN ('clerk','manager')
          AND 
          SAL>5000 ;

  => display employees earning more than 5000 and less than 10000 ?

    SELECT *
    FROM emp
    WHERE sal>5000 AND sal<10000 ;

 
 BETWEEN operator :- 

 => use BETWEEN operator when comparision with range.
 
       WHERE  COL BETWEEN V1 AND V2  (COL>=V1 AND COL<=V2)
       WHERE  COL NOT BETWEEN V1 AND V2 

 => display employees earning between 5000 and 10000 ?

    SELECT * FROM emp WHERE sal BETWEEN 5000 AND 10000 ; 

 => display employees whose age between 30 and 40 ?

    SELECT * FROM emp WHERE age BETWEEN 30 AND 40 ; 
 
 => display employees not joined in 2020 year ? 
 
    SELECT * 
    FROM emp 
    WHERE hiredate NOT BETWEEN '01-JAN-20' AND '01-JAN-21' ;

  
  Question :- 

   SELECT *
   FROM emp
   WHERE sal BETWEEN 10000 AND 5000 ; 

   A  ERROR
   B  RETURNS ROWS
   C  RETURNS NO ROWS
   D  NONE

 ANS :- C

  WHERE SAL BETWEEN 5000 AND 10000 (SAL>=5000 AND SAL<=10000)

  WHERE SAL NOT BETWEEN 10000 AND 5000 (SAL>=10000 AND SAL<=5000)

  NOTE :- use BETWEEN with lower and upper but not with upper and lower

 => display employees working as clerk,manager and earning between
    5000 and 10000 and joined in 2020 year and age between 30 and 40 ?

    SELECT *
    FROM emp
    WHERE job IN ('clerk','manager')
          AND
          sal BETWEEN 5000 AND 10000
          AND
          hiredate BETWEEN '01-JAN-20' AND '31-DEC-20'
          AND
          age BETWEEN 30 AND 40 ;

 Exercise :- 

  STUDENT
  SNO  SNAME  S1  S2  S3
  1    A      80  90  
  2    B      30  50  60

 => display list of students who are passed ?

    SELECT * FROM student WHERE s1>=35 AND s2>=35 AND s3>=35 ;

 => display list of students who are failed ?

    SELECT * FROM emp WHERE s1<35 OR s2<35 OR s3<35  ;
 

LIKE operator :- 

 => use LIKE operator when comparision based on pattern.

         WHERE COLNAME LIKE 'PATTERN'
         WHERE COLNAME NOT LIKE 'PATTERN'

 => pattern contains alphabets,digits,special chars and wildcard chars.

 wildcard chars :- 

   %         => 0 or many chars
   _         => exactly 1 char

  display employees name starts with 's' ?

  SELECT * FROM emp WHERE ename LIKE 's%';

  display employees name ends with 's' ?

  SELECT * FROM emp WHERE ename LIKE '%s';

  display employees name contains 'a' ? 

  SELECT * FROM emp WHERE ename LIKE '%a%'   
 
  where 'a' is the 3rd char in their name ?

  SELECT * FROM emp WHERE ename LIKE '__a%' ; 

  where 'a' is the 3rd char from last ?

  SELECT * FROM emp WHERE ename LIKE '%a__' ;

  display employees name contains 4 chars ?
 
  SELECT * FROM emp WHERE ename LIKE '____' ;
 
  display employees joined in JAN month ?

  SELECT * FROM emp WHERE hiredate LIKE '%JAN%' ;
 
  display employees joined in 2019 year ?

  SELECT * FROM emp WHERE hiredate LIKE '%19' ;

  
 Question :- 

  SELECT * FROM emp 
       WHERE job IN ('clerk','%man%') ;

  a error
  b returns clerk,manager rows
  c returns only clerk rows
  d none

  ANS :- c

 SELECT * FROM emp 
       WHERE job LIKE ('clerk','%man%') ; => error

 SELECT * FROM emp 
       WHERE job='clerk' OR job LIKE '%man%' ; => returns clerk,manager rows

 
scenario :-

 CUSTOMERS 
 cid    cname  
 10     sachin
 11     virat_kohli
 12	rohit%sharma

 => display customers name contains "_" ?

   SELECT * FROM cust WHERE cname LIKE '%_%' ;

  => above query returns all customer rows because "_" is treated 
as wildcard char but not treated as normal char. To overcome this
 problem use ESCAPE char.

  SELECT * FROM cust WHERE cname LIKE '%\_%'  ESCAPE '\' ;

 => display name contains "%" ?

  SELECT * FROM cust WHERE cname LIKE '%\%%' ESCAPE '\' ;


 IS operator :- 

 => use IS operator when comparision based on  NULL / NOT NULL

       WHERE COLNAME IS NULL
       WHERE COLNAME IS NOT NULL
 
 => display employees not earning salary ? 

   SELECT * FROM emp WHERE sal = NULL ;

   SELECT * FROM emp WHERE sal IS NULL ;

 => display employees earning salary ? 

  SELECT * FROM emp WHERE sal IS NOT NULL ;

 
 summary :- 

 WHERE COL IN (V1,V2,V3,--)
 WHERE COL BETWEEN V1 AND V2
 WHERE COL LIKE 'PATTERN'
 WHERE COL IS NULL 

 Expressions in SELECT clause :- 

 => display employee names and annual salaries ? 

   SELECT ename,sal*12
   FROM emp ;

05/01/21 :-
 
 ALIAS :- 

 => alias means another name or alternative name
 => used to change column headings.

        COLNAME [AS] ALIAS 

   SELECT ename,sal*12 AS ANNSAL
   FROM emp ; 

   SELECT ename,sal*12 AS ANNUAL SAL
   FROM emp ; 

   output :- ERROR

   SELECT ename,sal*12 AS "ANNUAL SAL"
   FROM emp ; 

   display ename,sal,hra,da,tax,totsal ? 
   
      hra = house rent allowance = 10% on sal
      da  = dearness allowance   = 30% on sal
      tax = 10% on sal
     totsal = sal + hra + da - tax 

   SELECT ename,sal,
          sal*0.1 as hra,
          sal*0.3 as da,
          sal*0.1 as tax,
          sal+(sal*0.1)+(sal*0.3)-(sal*0.1) as totsal
   FROM emp ; 

  
 DML commands :-  (Data Manipulation Language)

 insert
 update
 delete
 insert all
 merge 

         TABLE  = STRUCTURE(COLUMNS) + DATA (ROWS)
                     DDL                DML

 => DML commands acts on table data.
 => above operations performed on instance (RAM) 
 => to save these operations execute commit.
 => to cancel these operations execute rollback.
 
UPDATE command :- 

=> command used to modify data in a table.
=> using update command we can update all rows or specific rows.
 
  UPDATE <tabname>
  SET colname = value,colname = value,---
  [WHERE condition]

 => update all employees comm to 500 ? 

     UPDATE emp SET comm=500 

 => update employees comm to 500 whose comm = null ? 

     UPDATE emp SET comm=500 WHERE comm IS NULL ; 

 => update employees comm to null whose comm <> null ? 

     UPDATE emp SET comm = null WHERE comm IS not null ; 

             NULL assignment use  =
             NULL comparision use IS

 => increment sal by 20% and comm by 10% those working as salesman
 and joined in 1981 year ? 

   UPDATE emp 
      SET sal=sal+(sal*0.2),comm=comm+(comm*0.1)
    WHERE job='SALESMAN'
          AND
          hiredate LIKE '%81' ; 

 => transfer all employees from 10th dept to 20th dept ?
 
   UPDATE emp SET deptno = 20 WHERE deptno=10 ;

DELETE command :- 

 => command used to delete row/rows from table
 => we can delete all rows or specific rows
 
    DELETE FROM <tabname> [WHERE condition];

 => delete all rows from emp ?

    DELETE FROM emp ; 

 => delete employee row whose empno=7844 ? 

    DELETE FROM emp WHERE empno=7844 ;
 
 => delete employees having more than 40 years of experience ?

    DELETE FROM emp WHERE (sysdate-hiredate)/365 > 40 ;
 
 
 FLASHBACK :- 

 =>  introduced in oracle 10g.
 =>  using flashback we can see the data  that exists sometime back
 =>  a query that returns past data is called flashback query
 =>  useful to recover data after commit. 

 => display 5mins back data in emp table ? 

    SELECT * 
    FROM emp 
    AS OF TIMESTAMP(SYSDATE - INTERVAL '5' MINUTE);
  
 recovering data after commit :-  

    DELETE FROM emp;
    COMMIT;

  => to recover data after commit , get the data that exists 5 mins back
  and insert that data into current emp table as follows.

    INSERT INTO emp
    SELECT * 
    FROM emp 
    AS OF TIMESTAMP(SYSDATE-INTERVAL '5' MINUTE);
  
 Undo retention :- 

 => default undo retention is 900 seconds i.e. we can flashback upto
   900 seconds i.e. 15 mins. 

 => To alter undo retention execute the following command 
  system/manager

    username :- system/manager

  SQL>ALTER SYSTEM SET UNDO_RETENTION = 2400;

 DDL commands :- 

 create
 alter
 drop
 truncate
 rename
 flashback
 purge

 
 => DDL commands acts on table structure
 => all DDL commands are auto committed.

    DDL command = DDL command + commit 

 scenario 1 :- 

 create table a(a number(2));
 insert into a values(10);
 insert into a values(20);
 insert into a values(30);
 insert into a values(40);
 rollback ;

 output :-  create table is saved
            inserts are cancelled
 
 scenario 2 :- 

 create table a(a number(2));
 insert into a values(10);
 insert into a values(20);
 create table b(b number(2)); => commit 
 insert into a values(30);
 insert into a values(40);
 rollback ;

 output :- 

  create table a,b  => saved
  insert 10,20      => saved
  insert 30,40      => cancelled

 
  ALTER command :-

  => command used to modify table structure
  => using ALTER we can

 1 add column
 2 remove column
 3 rename column
 4 modify column`````````````````````
 
 Adding columns :- 

  ALTER TABLE <TABNAME>
       ADD (COLNAME DATATYPE(SIZE),---------);

 => add column gender to emp table ? 

   ALTER TABLE emp
        ADD(gender CHAR(1));

 => after adding, use UPDATE command to fill the column with data.

     UPDATE emp SET gender='&gender' WHERE empno=&empno;

 Removing a column :- 

  ALTER TABLE <TABNAME>
      DROP  (COL1,COL2,---);

 => drop gender from emp ? 

    ALTER TABLE emp
            DROP (gender);

 Renaming a column :- 

 ALTER TABLE <TABNAME>
     RENAME COLUMN <OLDNAME> TO <NEWNAME> ;

 => rename column COMM to BONUS ? 

  ALTER TABLE emp 
       RENAME COLUMN COMM TO BONUS ; 

  
  SELECT empno,ename,sal,comm as bonus FROM emp ; 
 

  what is the diff b/w alias and rename ?

        rename                 alias 

   1   permanent                temporary

   2   changes column name      changes column heading in select
       in table                 statement output

 Modifying a column :- 

  ALTER TABLE <TABNAME>
      MODIFY (COLNAME DATATYPE(SIZE));

 1 changing size
 2 changing datatype

 => increase size of ename to 20 ?

   ALTER TABLE emp 
       MODIFY (ename VARCHAR2(20));

   
   ALTER TABLE emp 
       MODIFY (ename VARCHAR2(5));  => ERROR

 
 => ALTER TABLE emp
       MODIFY (sal NUMBER(6,2)); => ERROR

 NOTE :- column must be empty to decrease precision or scale.

 
    ALTER TABLE emp
       MODIFY(empno VARCHAR2(10)); => ERROR

 NOTE :- column must be empty to change datatype.

 
 DROP command :- 

 => command used to drop table from database.
 => drops table structure al ong with data.

        DROP TABLE <TABNAME> ;

      EX :- DROP TABLE emp ; 
   
=> prior to 10g ver when table is dropped it is permanently removed
   from database and cannot be restored. 

 => from 10g when table is dropped it is moved to recyclebin. To
 see the contents of recyclebin execute the following command.

   SQL>SHOW RECYCLEBIN 

 FLASHBACK command :- 

 => introduced in 10g ver.
 => command used to recover the table from recyclebin.
 
   syn :- FLASHBACK TABLE <TABNAME> TO BEFORE DROP ;

   Ex :-  FLASHBACK TABLE EMP TO BEFORE DROP ; 

  => table is restored with columns & rows that exists before drop.
 
 PURGE command :- 

 => used to delete object from recyclebin.
 => after deleting object from recyclebin we cannot flashback the table

    syn :- PURGE TABLE <TABNAME> 

    ex :- PURGE TABLE emp;

          PURGE RECYCLEBIN;

          DROP TABLE emp PURGE ;
 
 TRUNCATE command :- 
   
 => deletes all the data from table but keeps structure
 => will empty the table
 => releases memory allocated for table

    syn :- TRUNCATE TABLE <tabname> 

    ex :-   TRUNCATE TABLE cust;

  => when the above command is submitted , oracle goes to db and
 releases all the blocks allocated for table when memory is released
 then data stored in the memory also deleted.

 DROP VS DELETE VS TRUNCATE  :- 

 
   DROP                DELETE               TRUNCATE

1  DDL                 DML                  DDL

2  drops table         deletes only data    deletes only data but
   structure with      but not structure    not structure
   data


 DELETE VS TRUNCATE :- 

        DELETE                    TRUNCATE

   1    DML                       DDL 

   2   delete can delete          can't delete specific rows
       specific row/rows          deletes only all rows

   3   where cond can be          where cond cannot be used with
       used with delete           truncate

   4   can be rolledback          can't be rolledback

  
   5   we can flashback after      we cannot flashback after truncate
       delete
 

   6  deletes row-by-row           deletes all rows at a time

   
   7  slower                       faster

   8  will not release memory      releases memory

   
  RENAME :- 

  => used to change tablename 

    RENAME  <OLDNAME> TO <NEWNAME> 

  EX :- RENAME STUDENT TO STUD 

 creating new table from existing table :- 

 CREATE TABLE <NEW-TABNAME>
 AS
 SELECT <COLS> FROM <OLD-TABNAME>;

 Example 1 :- 

 CREATE TABLE EMP10
 AS
 SELECT * FROM EMP 

 => a new table is created with name EMP10 and structure & data
  of EMP table is copied to EMP10.

 Example 2 :- copying specific columns and rows 

 CREATE TABLE EMP11
 AS
 SELECT empno,ename,sal,job FROM emp
 WHERE job IN ('CLERK','MANAGER')

 Example 3 :- copying only structure but not data 

 CREATE TABLE emp12
 AS
 SELECT * FROM emp WHERE 1=2

Example 4 :- copying table from one user to another user 

 copy customers table from SH to BATCH7AM ?

 system :-
 
 CREATE TABLE BATCH7AM.CUSTOMERS
 AS
 SELECT * FROM SH.CUSTOMERS 

copying data from one table to another table :- 

 INSERT INTO <TARGET-TABLE>
 SELECT COLUMNS FROM <SOURCE-TABLE> ;

 copy data from EMP to EMP12 ?

 INSERT INTO emp12
 SELECT * FROM emp;

 MERGE command :- 

 => introduced in oracle 9i
 => command used to merge data into a table
 => merge is the combination of insert & update
 => used to manage replicas

 syntax :-

  MERGE INTO <target-table> <alias>
  USING <source-table> <alias>
  ON (condition)
  WHEN matched THEN
   UPDATE
  WHEN not matched THEN
   INSERT

scenario :- 

08-JAN-21 :-

 CUSTS
 CID  CNAME  CADDR
 10   A      HYD
 11   B      MUM

 create replica of custs ?

 CREATE TABLE CUSTR
 AS
 SELECT * FROM CUSTS ;

 CUSTR
 CID  CNAME  CADDR
 10   A      HYD
 11   B      MUM

09-JAN-21 :- 

 
 CUSTS
 CID  CNAME  CADDR
 10   A      BLR  => updated 
 11   B      MUM
 12   C	     DEL  => inserted

 => use MERGE command to apply changes made to CUSTS to CUSTT

Example :- 

 MERGE INTO CUSTR T
 USING CUSTS S
 ON (S.CID = T.CID)
 WHEN MATCHED THEN
   UPDATE SET T.CADDR = S.CADDR
 WHEN NOT MATCHED THEN
   INSERT VALUES(S.CID,S.CNAME,S.CADDR)


 CUSTS
 CID  CNAME  CADDR
 10   A      BLR  => updated 
 11   B      MUM
 12   C	     DEL  => inserted

 
 CUSTR
 CID  CNAME  CADDR
 10   A      BLR
 11   B      MUM
 12   C	     DEL  

 
-----------------------------------------------------------------------

 Built-in functions in ORACLE :- 

 => a function accepts some input performs some calculation and
 returns one value.

 Types of functions in ORACLE :- 

 1 string
 2 date
 3 mathematical
 4 conversions
 5 special
 6 analytical / OLAP
 7 group / aggregate

 string functions :- 

 UPPER() :- 

 => converts string to uppercase 

    UPPER(string) 

  SELECT UPPER('hello') FROM DUAL ; 

 DUAL :- it is a dummy table provided by oracle and used to select
 non db values.

 LOWER() :- 

 => converts string to lowercase

   LOWER(string)

  SELECT LOWER('HELLO') FROM DUAL; => hello 

  display EMPNO,ENAME,SAL ? display names in lowercase ?

  SELECT empno,LOWER(ename) as ename,sal FROM emp ; 

  convert names to lowercase in table ?

  UPDATE emp SET ename = LOWER(ename) ; 

  display employee details whose name = BLAKE ?

  SELECT * FROM emp WHERE ename = 'BLAKE' ; => NO ROWS 

 =>  in oracle string comparision is case sensitive. To do case
  insensitive comparision use UPPER/LOWER functions.

  SELECT * FROM emp WHERE UPPER(ename)='BLAKE' ; 
  
  SELECT * FROM emp WHERE LOWER(ename)='blake' ; 

  INITCAP() :- converts initials into capitals.

  SELECT INITCAP('hello welcome') FROM DUAL; => Hello Welcome
 
 LENGTH() :- 

 => returns string length i.e. no of chars.

     LENGTH(string) 

  SELECT LENGTH('hello') FROM DUAL ; => 5

  SELECT LENGTH('hello welcome') FROM DUAL ; => 13 

  display employee list name contains 4 chars ? 
 
  SELECT * FROM emp WHERE ename LIKE '____' ;

  SELECT * FROM emp WHERE LENGTH(ename)=4 ;   
 
 SUBSTR() :- used to extract part of the string.

    SUBSTR(string,start,[length])

  
  SUBSTR('hello welcome',7,4)   => welc
  SUBSTR('hello welcome',7)     => welcome
  SUBSTR('hello welcome',-4,3)  => com
  
 => employee list name starts with 's' ? 

   SELECT * FROM emp WHERE ename LIKE 's%'  ;

   SELECT * FROM emp WHERE SUBSTR(ename,1,1)='S' ;
 
 => employees name starts and ends with same char ?

   SELECT * FROM emp WHERE ename LIKE 'A%A'
                           OR
                           ename LIKE 'B%B'

   SELECT * FROM emp WHERE SUBSTR(ename,1,1) = SUBSTR(ename,-1,1);
  

  generate emailids as follows ? 

  EMPNO  ENAME   EMAILID
  7369   SMITH   smi736@oracle.com
  7499   ALLEN   all749@oracle.com

  SELECT empno,ename,
         SUBSTR(LOWER(ename),1,3)||SUBSTR(empno,1,3)||'@oracle.com'
                       as emailid
  FROM emp ;

  => store emailids in db ?

  1 add column emailid to emp 

  ALTER TABLE emp 
        ADD (emailid VARCHAR2(30));

 2 update column with emailids 

  UPDATE emp 
  SET emailid = SUBSTR(LOWER(ename),1,3)||SUBSTR(empno,1,3)||'@oracle.com';

 LPAD & RPAD :- 

 => both functions are used to fill string with a char.

  LPAD(string,len,char) => fills on left side
  RPAD(string,len,char) => fills on right side

  LPAD('hello',10,'*')  => *****hello 
  RPAD('hello',10,'*')  => hello*****

  RPAD('*',10,'*')      => **********
  
  display ENAME,SAL ?
                ***
                ****
                *****

 SELECT ename,RPAD('*',LENGTH(SAL),'*') AS SAL FROM emp ;

 scenario :- 

 ACCOUNTS
 ACCNO 
 12345678978

 your a/c no XXXX8978 debited --- ? 

  LPAD('X',4,'X')||SUBSTR(accno,-4,4)

LTRIM,RTRIM,TRIM :- 

=> used to remove spaces and unwanted characters.

 LTRIM(str1,[str2])    => removes on left side
 RTRIM(str1,[str2])    => removes on right side
 TRIM(str)             => removes on both sides 

 LTRIM('  hello  ')    => 'hello   '
 RTRIM('  hello  ')    => '   hello'
 TRIM('   hello  ')    =>  hello

 LTRIM('@@@hello@@@','@')         => hello@@@
 RTRIM('@@@hello@@@','@')         => @@@hello
 TRIM(both '@' from @@@hello@@@') => hello

 REPLACE() :- 

 => used to replace one string with another string

  REPLACE(str1,str2,str3)

 => in str1 ,  str2 replaced with str3

  REPLACE('hello','ell','abc')  => habco
  REPLACE('hello','l','abc')    => heabcabco
  REPLACE('hello','ell','')     => ho
  
TRANSLATE() :- 

 => used to translate one char to another char.

   TRANSLATE(str1,str2,str3) 

   TRANSLATE('hello','elo','abc') => habbc
  
     e  => a
     l  => b
     o  => c 

   => translate function can be used to encrypt data 

   DISPLAY ename,sal  ?

   SELECT ename,TRANSLATE(sal,'0123456789','$bP*g@K^t#') as sal
   FROM emp ;
   
 INSTR() :- 

 => returns position of  a char in a string.

   INSTR(string,char,[start,occurance])

 INSTR('hello welcome','o')      =>  5
 INSTR('hello welcome','x')      =>  0
 INSTR('hello welcome','o',1,2)  => 11
 INSTR('hello welcome','e',1,3)  => 13
 INSTR('hello welcome','e',-1,2) => 8

----------------------------------------------------------------------

 Conversion Functions :- 

 => used to convert one type to another type
 => conversion is 2 types 

   1 implicit conversion
   2 explicit conversion

 implicit conversion :- 

 => if conversion performed by oracle then it is called implicit conversion

 Examples   :- 

 1  SELECT 1000 + '1000' FROM DUAL; => 2000

 => string '1000' automatically converted to number

 2  CREATE TABLE D(D DATE);

    INSERT INTO D VALUES('19-JAN-21');

 => string '19-JAN-21' is automatically converted to date

 NOTE :- 

 => implicit conversion is not recommended because it degrades
 performance better to use explicit conversion.

 Explicit Conversion :- 

 => if conversion performed by user then it is called explicit
 conversion. The following functions provided by oracle for
 explicit conversion.

  1 TO_CHAR
  2 TO_DATE
  3 TO_NUMBER

 converting date to char type :- 

 => dates converted to char type to display dates in different formats

              TO_CHAR(date,[format])       (date=sysdate)

   formats :- 

   yyyy                2021
     yy                21 
     cc(centuary)      21                                 
   AD/BC               AD year / BC year

     mm                01
     mon / MON         jan/JAN
     month / MONTH     january / JANUARY

     dd                19   (day of the month)
     ddd               19   (day of the year)
     d                 3     (day of the week)
    
                              1 sunday
                              2 monday
                              3 tuesday

                              7 saturday

     dy / DY           tue / TUE
     day / DAY         tuesday / TUESDAY

     Q                 Quarter (1-4)

                        1  jan-mar
                        2  apr-jun
                        3  jul-sep
                        4  oct-dec

     w                  week of the month
     ww                 week of the year 

     hh                 hour
     hh24               hour part in 24 hrs format
     mi                 minutes
     ss                 seconds
    AM/PM               AM time OR PM time

 => display employees joined in 1981 year ?
 
    SELECT * FROM emp WHERE TO_CHAR(hiredate,'YYYY') = 1981 ;
    
 => display employees joined in 1980,1983,1985 ?

    SELECT * FROM emp 
         WHERE TO_CHAR(hiredate,'YYYY') IN (1980,1983,1985) ;

 => display employees joined in jan,apr,dec months ?

    SELECT * FROM emp 
          WHERE TO_CHAR(hiredate,'mm') IN (01,04,12);

 => display employees joined on sunday ?
 
        SELECT * FROM emp 
           WHERE TO_CHAR(hiredate,'dy')='sun'  ;

 => display employees joined in 2nd quarter of 1981 year ?

    SELECT * FROM emp 
         WHERE  TO_CHAR(hiredate,'yyyy') = 1981
                AND
                TO_CHAR(hiredate,'Q') = 2 

 => display current date & time ? 

    SELECT TO_CHAR(sysdate,'mm/dd/yy hh:mi PM day')
    FROM DUAL ;


    SELECT ename,TO_CHAR(hiredate,'mm/dd/yy hh:mi PM day')
    FROM emp;

  => display employees joined today ?

     INSERT INTO emp(empno,ename,job,sal,hiredate)
         VALUES(1000,'abc','clerk',2000,sysdate); => 20-JAN-21 7:23:30

   
    SELECT * FROM emp 
         WHERE hiredate = sysdate ;  => NO ROWS 

       20-jan-21 7:23:30   20-jan-21 17:00:00

  => "=" comparision with sysdate will not work to overcome this problem
   use TO_CHAR function.
 
   SELECT * FROM emp 
     WHERE TO_CHAR(hiredate,'mm/dd/yyyy')=TO_CHAR(sysdate,'mm/dd/yyyy');

  converting date string to date :- 

   date string => '20-JAN-21'
                  '01/20/21'

      TO_DATE(date string,[format])

  Examples :- 

  1  SELECT SYSDATE + 10 FROM DUAL ; => 30-JAN-21

  2  SELECT '20-MAR-20' + 80 FROM DUAL ; => error


   number + number => valid
   date   + number => valid
   string + number => invalid

  3 SELECT TO_DATE('20-MAR-20') + 80 FROM DUAL; => 08-JUN-20

  4 SELECT TO_DATE('01/20/21','MM/DD/YY') + 40 FROM DUAL ; => 01-MAR-21
 

  5 write a query to display on which day india got independence ?

   SELECT TO_CHAR(TO_DATE('15-AUG-1947'),'day') FROM DUAL ; 

  how to insert dates in different formats :- 

  SQL>CREATE TABLE D(D DATE);

  SQL>INSERT INTO D VALUES(TO_DATE('&D','MM/DD/YY'));
      enter value for D :- 01/20/21

   1 ROW CREATED

  SQL>/
     enter value for D :- 10/15/20

   1 ROW CREATED

   SQL>SELECT * FROM D ;

     20-JAN-21
     15-OCT-21

  how to insert date & time :- 

 using DATE datatype :-

  SQL>CREATE TABLE D(D DATE);

  SQL>INSERT INTO D VALUES('20-JAN-21 7:53:00'); => ERROR

  SQL>INSERT INTO D VALUES(TO_DATE('&D','DD-MON-YY HH:MI:SS'));
    enter value for D :- 20-JAN-21 7:53:00

   1 ROW CREATED 

 using TIMESTAMP datatype :- 

  SQL>CREATE TABLE D(D TIMESTAMP);

  SQL>INSERT INTO D VALUES('20-JAN-21 7:53:00');  

  diff b/w DATE & TIMESTAMP ? 

     DATE                         TIMESTAMP

=> requires conversion            without conversion we can insert
   to insert date & time          date & time


 converting number to char type :- 

 => numbers converted to char type to display numbers in different
 formats.

           TO_CHAR(number,[format])

 
  formats :- 

   0                       represents a digit
   9                       represents a digit
   ,                       thousand seperator
   .                       decimal seperator
   L                       currency symbol
   C                       currency


  TO_CHAR(1234,'000000')     =>  001234
  TO_CHAR(1234,'999999')     =>  1234  
  TO_CHAR(1234,'9,999')      =>  1,234
  TO_CHAR(1234,'9,999.99')   =>  1,234.00
  TO_CHAR(1234,'L9,999')     =>  $1,234
  TO_CHAR(1234,'C9,999')     =>  USD1,234
  
  SELECT ename,TO_CHAR(sal,'L99,999') AS SAL 
  FROM emp;
 
  How to change currency ? 

  ALTER SESSION SET NLS_TERRITORY='INDIA'; 
 
 converting numeric string to number :- 

   TO_NUMBER(numeric string,[format])
  
    numeric string  => '1234' , '1,234' , '$1,234'

  
  1 SELECT 1000 + '1,000'  FROM DUAL ; =>   ERROR

  2 SELECT 1000 + TO_NUMBER('1,000','9,999') FROM DUAL; => 2000

  3 SELECT 1000 + TO_NUMBER('$1,000','L9,999') FROM DUAL ; => 2000

  
          INPUT        OUTPUT         FUNCTION
          SYSDATE      01/21/21       TO_CHAR
          01/21/21     21-JAN-21      TO_DATE   
     
          default      other          TO_CHAR
          other        default        TO_DATE

          5000         $5,000         TO_CHAR
          $5,000       5000           TO_NUMBER

Mathematical Functions :- 

1 power() :-  

   power(3,2) => 9

2 sqrt() :- 

   sqrt(16) => 4 

3 abs() :- 

  abs(-10) => 10 

4 sign() :- 

   sign(10)  => 1
   sign(-10) => -1
   sign(0)   => 0

 5 MOD() :- returns remainder

     MOD(10,2)  => 0

  => display employees earning multiples of 100 ?
   
     SELECT * FROM emp WHERE MOD(sal,100)=0 ;

  => display employees joined in leap year ?

     SELECT * FROM emp 
          WHERE MOD(TO_CHAR(hiredate,'YYYY'),4)=0 ;
   
 rounding numbers :-

 ROUND
 TRUNC
 CEIL
 FLOOR

 ROUND :- 

 => rounds number to integer or to decimal places based on avg.

          ROUND(number,[decimal places])

  ROUND(38.4567)     =>  38
 
     38-----------------38.5----------------39

 number < avg  => rounded to lowest
 number >= avg => rounded to highest

 ROUND(38.5678)     =>  39
 ROUND(38.4567,2)   =>  38.46
 ROUND(38.4567,3)   =>  38.457

 ROUND(386,-2)      => 400

    300----------------350------------------400

 ROUND(386,-1)      => 390

    380---------------385-------------------390

 ROUND(386,-3)      => 0

    0------------------500--------------------1000
 
 display ENAME,EXPERIENCE ?

 SELECT ename,ROUND((sysdate-hiredate)/365) as expr
 FROM emp ;

 TRUNC :- 

 => rounds number always to lowest 

  TRUNC(number,[decimal places])

  TRUNC(38.5678)    => 38

   38-------------------------------39

  TRUNC(38.5678,2)  => 38.56
 
  TRUNC(386,-2)     => 300

   300--------------------------------400

  TRUNC(386,-1)     => 380
 
  380------------------------------390


 Question :- 

   CREATE TABLE X(X NUMBER(7,2));

   INSERT INTO X VALUES(4567);

   4500-----------4550----------------4600
 
   SELECT * fROM X;
 
   4600

  NOTE :- by default oracle uses ROUND function while inserting data into table

   
   create table x(x number(7,2));

   insert into x values(456.347627272)

   select * From x ;
 
   456.35

 
 CEIL() :- rounds number always to highest

  CEIL(number)

 
   CEIL(3.1)    =>   4

 FLOOR() :- rounds number always to lowest 

     FLOOR(number)

  FLOOR(3.9)   => 3

    
 Question :- 

   display  ENAME    EXPERIENCE  ? 
                     M YEARS N MONTH

   Experience =  40 MONTHS  = 3 YEARS 4 MONTHS 

     YEAR  =   MONTHS/12      = 3 
    
     MONTHS =  MOD(MONTHS,12) = 4 

  DATE functions :- 

  ADD_MONTHS() :- used to add/subtract months to/from a date

   ADD_MONTHS(date,months)

  ADD_MONTHS(sysdate,2)  => 23-mar-21
  ADD_MONTHS(sysdate,-2) => 23-NOV-20
  
   display ENAME,HIREDATE,DOR  ? 

   DOR = DATE OF RETIREMENT = HIREDATE + 40 YEARS 

   SELECT ENAME,HIREDATE,
          ADD_MONTHS(HIREDATE,40*12) AS DOR
   FROM EMP; 

 scenario :- 

 GOLD_RATES										
 DATEID	       RATE
 01-JAN-15     ?
 02-JAN-15     ?

 23-JAN-21     ?        10:00:00

 
  1  display today's gold rate ?

     SELECT RATE FROM GOLD_RATES 
        WHERE TO_CHAR(DATEID,'dd-mon-yy') =  TO_CHAR(SYSDATE,'dd-mon-yy') ;

     SELECT RATE FROM GOLD_RATES 
         WHERE TRUNC(DATEID) = TRUNC(SYSDATE) ; 
                      
                23-JAN-21 00:00:00 = 23-JAN-21 00:00:00

  2  display yesterday's gold rate ?

     SELECT RATE FROM GOLD_RATES 
             WHERE TRUNC(DATEID) =  TRUNC(SYSDATE) - 1 

  3  display last month same day gold rate ?

     SELECT RATE FROM GOLD_RATES
             WHERE TRUNC(DATEID) = ADD_MONTHS(TRUNC(SYSDATE),-1)

  4  display last year same day gold rate ? 

     SELECT RATE FROM GOLD_RATES
         WHERE TRUNC(DATEID) =  ADD_MONTHS(TRUNC(SYSDATE),-12)); 

  
 from oracle 9i :- 

 => oracle 9i onwards we can different intervals to date 

   add 10 days to sysdate ? 

   SELECT SYSDATE + INTERVAL '10' DAY FROM DUAL ; 
   
  add 2 montsh to sysdate ?

   SELECT SYSDATE + INTERVAL '2' MONTH FROM DUAL; 
  
   add 2 years to sysdate ? 

   SELECT SYSDATE + INTERVAL '2' YEAR FROM DUAL; 
   
   add 1 1/2  year to sysdate ? 

   SELECT SYSDATE + INTERVAL '1-6' YEAR TO MONTH FROM DUAL; 

   display date & time ?

   SELECT SYSTIMESTAMP FROM DUAL ;

   add 1 hour to current time ? 

   SELECT SYSTIMESTAMP + INTERVAL '1' HOUR FROM DUAL;

   add 1 hour 30 minutes to current time ?

   SELECT SYSTIMESTAMP + INTERVAL '1:30' HOUR TO MINUTE FROM DUAL;

  MONTHS_BETWEEN() :- 

  => returns no of months between two dates 

    MONTHS_BETWEEN(date1,date2) 

    SELECT MONTHS_BETWEEN(SYSDATE,'23-JAN-20') FROM DUAL ; 

    display ENAME,EXPERIENCE in months ?

    SELECT ENAME,
         FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)) AS EXPR
    FROM EMP ;     
    
    display ENAME,EXPERIENCE ?
                  M YEARS N MONTHS 

     EXPERIENCE = 38 MONTHS    =    3 YEARS 2 MONTHS
     YEARS = MONTHS/12         =    3
      MONTHS = MOD(MONTHS,12)   =    2 
  
      SELECT ENAME,
      FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12) YEARS,
      MOD(FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)),12) AS MONTHS
      FROM EMP 
   
   LAST_DAY() :- returns last day of the month ? 

     LAST_DAY(date)  

   SELECT LAST_DAY(SYSDATE) FROM DUAL ;    

   display 1st day of the next month ? 

    SELECT LAST_DAY(SYSDATE)+1 FROM DUAL ;  
       
   display current month 1st day ? 

   prev month last day + 1 

   SELECT LAST_DAY(ADD_MONTHS(SYSDATE,-1))+1  FROM DUAL ; 

 NEXT_DAY() :- 

 => returns next specified by from given date

    NEXT_DAY(date,day)

  SELECT NEXT_DAY(SYSDATE,'SUNDAY') FROM DUAL ;  => 31-JAN-21

  display next month first sunday ? 

  display current month last sunday ?
 
  display current month first sunday ?
   
 
 SPECIAL FUNCTIONS :- 

 NVL() :- 

 => used to convert null values.

    NVL(arg1,arg2) 

  if arg1 = null returns arg2
  if arg <> null returns arg1 only

  NVL(100,200)     =>   100
  NVL(NULL,200)    =>   200
  
  display ENAME,SAL,COMM,TOTSAL ? 

   TOTSAL = SAL + COMM 

  SELECT ENAME,SAL,COMM,SAL+COMM AS TOTSAL
  FROM EMP ;

  smith   800   null    null
  allen  1600   300     1900

 SELECT  ENAME,SAL,COMM,SAL+NVL(COMM,0) AS TOTSAL
 FROM EMP ;

 smith  800    null    800 
 allen 1600    300     1900
 
 display ENAME,SAL,COMM ? 
 
   if comm = NULL display N/A 

 SELECT ename,sal,NVL(comm,'N/A') as comm
 FROM emp ; 

 OUTPUT :- ERROR

  SELECT ename,sal,NVL(TO_CHAR(comm),'N/A') as comm
  FROM emp ; 

 NVL2() :- 

 => used to convert both nulls and not nulls 

    NVL2(arg1,arg2,arg3)

 if arg1 = null returns arg3
    arg1 <> null returns arg2   <> think value available

 NVL2(100,200,300)     =>  200

 NVL2(NULL,200,300)    =>  300

 => update employee sal as follows ? 

   if comm=null update with 500
   if comm<>null incr by 200 ? 

  UPDATE emp SET comm = NVL2(comm,comm+200,500)  ; 

  ASCII() :- returns ascii value of a given char

     ASCII('A') => 65

 CHR() :- returns character for given ascii value

     CHR(65) => A 

  SELECT 'A'||CHR(10)||'B' FROM DUAL; => A
                                         B

  CUST
  CID  CNAME   HNO  STREET  CITY  STATE 


  display  CNAME
           HNO
           STREET
           CITY
           STATE 

  SELECT CNAME||CHR(10)||
         HNO||CHR(10)||
         STREET||CHR(10)||
         CITY||CHR(10)||
         STATE
  FROM CUST
  WHERE CID = 10 ;

----------------------------------------------------------------------

Analytical Functions :- (OLAP) 

RANK,DENSE_RANK :- 

=> both functions are used to calculate ranks 
=> ranking always based on some column or expression
=> rank functions accepts only ordered data
    
         RANK() OVER (ORDER BY colname ASC/DESC)
         DENSE_RANK() OVER (ORDER BY colname ASC/DESC)

 Example 1 :-

 => Display ranks of the employees based on sal and highest paid
  employee should get 1st rank ? 

  SELECT empno,ename,sal,
       rank() over (order by sal DESC) as rnk
  FROM emp ;
 
  
   SELECT empno,ename,sal,
       dense_rank() over (order by sal DESC) as rnk
  FROM emp ;


  diff b/w rank & dense_rank ? 

          rank                          dense_rank

 1  generates gaps                      will not generate gaps 


 2  ranks may not be in sequence         ranks are always in sequence


	   SAL		RNK		DRNK
	   5000		1		1
	   4000		2		2
	   3000		3		3
	   3000		3		3
	   3000		3		3
	   2000		6		4
	   2000		6		4
         1000		8		5			

 
 Example 2 :- 

  Display ranks based on salary if salaries are same then ranking
  should be based on experience ? 

  
  SELECT empno,ename,hiredate,sal,
       dense_rank() over (order by sal DESC,hiredate ASC ) as rnk
  FROM emp ;
   
 PARTITION BY clause :- 
 ----------------------

 => partition by clause is used to calculate ranks with in group.
  for example to calculate ranks with in dept first we need to
  divide the table dept wise using partition by clause and 
  apply dense_rank function on each partition instead of applying
  dense_rank function on whole table.

  display ranks of the employees with in dept based on sal and
  highest paid employee should get 1st rank ?

  SELECT deptno,empno,ename,sal,
         dense_rank() over (partition by deptno
                            order by sal desc) as rnk
  FROM emp ;

 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- :- 

 => returns record numbers 
 => row_number is also based on some column
 => row_number also requires ordered data 

    ROW_NUMBER() OVER (ORDER BY COL ASC/DESC)

  SELECT empno,ename,sal,
         ROW_NUMBER() OVER (ORDER BY EMPNO ASC) AS RNO
  FROM EMP ; 
 
scenario :-

 STUDENT
 SNO  SNAME  M  P  C
 1    A     80  90 70
 2    B     90  70 80

 => display ranks of the students based on avg if avg is same then
 ranking should be based on maths ? 
 
---------------------------------------------------------------------

GROUP / AGGREGATE functions :- 
 
 => these functions process group of rows and returns one value
 
 MAX() :- returns maximum value

  MAX(arg)

 SELECT MAX(sal) FROM emp ;     => 5000

 SELECT MAX(hiredate) FROM emp ;

 MIN() :- returns minimum value

  MIN(arg) 

  SELECT MIN(sal) FROM emp ;  => 800


 SUM() :- returns total 


  SUM(arg) 

  SELECT SUM(sal) FROM emp ;  => 31025 

  display total sal with currency symbol and thousand seperator ? 

    SELECT TO_CHAR(ROUND(SUM(sal),-2),'L99,999') AS TOTSAL
    FROM emp ;
 
 
    31000----------------31050----------------31100

  AVG() :- returns average value 

   AVG(arg) 

  SELECT AVG(SAL) FROM EMP ; => 2068.33333

  => round avg(sal) to lowest ? 

   SELECT FLOOR(AVG(SAL)) FROM EMP ; => 2068

  NOTE :- sum,avg cannot be applied on date,char columns 

    SELECT SUM(hiredate) FROM emp ; => ERROR

 COUNT() :- returns no of values in a column

   COUNT(arg) 

  SELECT COUNT(empno) FROM emp; =>  15
 
  SELECT COUNT(comm) FROM emp;  => 4

  NOTE :- COUNT function ignores nulls 

  SELECT COUNT(JOB) FROM EMP ; => 15 

  SELECT COUNT(DISTINCT JOB) FROM EMP ; => 6
  
 COUNT(*) :- returns no of rows in a table.

  SELECT COUNT(*) FROM emp; => 15 

 T1
 F1
 10
 NULL
 20
 NULL
 30 

  COUNT(F1) =  3
  COUNT(*)  =  5 
 
  SELECT COUNT(1) FROM EMP ; => 15 

  => COUNT(1) is faster than COUNT(*) 

  display no of employees joined in 1981 year ?

  SELECT COUNT(*) FROM emp WHERE TO_CHAR(hiredate,'yyyy')=1981;

  display no of employees joined on sunday ? 

  SELECT COUNT(*) FROM emp WHERE TO_CHAR(hiredate,'d')=1;

  SELECT COUNT(*) FROM emp WHERE TO_CHAR(hiredate,'dy')= 'sun';

 SELECT COUNT(*) FROM emp WHERE TO_CHAR(hiredate,'fmday')='sunday';

 OR

  SELECT COUNT(*) FROM emp 
         WHERE RTRIM(TO_CHAR(hiredate,'day'))='sunday';
                                 

 display no of employees joined in 2nd quarter of 1981 year ? 

 SELECT COUNT(*) FROM emp 
        WHERE TO_CHAR(hiredate,'yyyy') = 1981 
              AND
              TO_CHAR(hiredate,'q') = 2 ;


   
 summary :- 

 string :- upper,lower,initcap,length,substr,instr,lpad,rpad,
 ltrim,rtrim,trim,replace,translate

 date :- add_months,months_between,last_day,next_day

 math :- power,sqrt,abs,sign,round,trunc,ceil,floor

 conv :- to_char,to_number,to_date

 special :- NVL,NVL2,ASCII,CHR 

 analytical :- rank,dense_rank,row_number

 group  :-  max,min,sum,avg,count,count(*)

----------------------------------------------------------------------

 how to implement IF-THEN-ELSE :- 

  1 CASE statement
  2 DECODE function

 CASE statement :- 

 => introduced in oracle 9i
 => used to implement IF-THEN-ELSE
 => case statements are 2 types 

  1 simple case 
  2 searched case 

 simple case :- 

 => use simple case when conditions based on "=" operator.

 CASE EXPR/COLNAME
 WHEN VALUE1 THEN RETURN EXPR1
 WHEN VALUE2 THEN RETURN EXPR2
 --------------------
 [ELSE RETURN EXPR]
 END

 Example 1 :-

  display ENAME,JOB ? 

  IF job=CLERK display WORKER
         MANAGER       BOSS
         PRESIDENT     BIG BOSS
         OTHERS        EMPLOYEE

  SELECT ename,
         CASE job
         WHEN 'CLERK' THEN 'WORKER'
         WHEN 'MANAGER' THEN 'BOSS'
          WHEN 'PRESIDENT' THEN 'BIG BOSS'
         ELSE  job
         END AS job
  FROM emp ; 

 Example 2 :- 

 => increment employee salaries as follows 

  if deptno=10 incr sal by 10%
            20             15%
            30             20%
        OTHERS             5%

 UPDATE emp SET sal = CASE deptno 
                      WHEN 10 THEN sal+(sal*0.1)
                      WHEN 20 THEN sal+(sal*0.15)
                      WHEN 30 THEN sal+(sal*0.2)
                      ELSE sal+(sal*0.05)
                      END ;

searched case :- 

 => use searched case when conditions not based on "=" operator.

   CASE 
   WHEN COND1 THEN RETURN EXPR1
   WHEN COND2 THEN RETURN EXPR2
   ----------------
   [ELSE RETURN EXPR]
   END

Example 1 :-

 display ENAME,SAL,SALRANGE ? 

         IF SAL>3000 display Hisal
            SAL<3000 display Losal
            SAL=3000 display Avgsal


 SELECT ename,sal,
        CASE 
        WHEN sal>3000 THEN 'Hisal'
        WHEN sal<3000 THEN 'Losal'
        ELSE 'Avgsal'
        END  as salrange
 FROM emp ;

Example 2 :- 

 STUDENT
 SNO  SNAME  S1  S2  S3
 1    A      80  90  70
 2    B      30  60  50

 display SNO,TOTAL,AVG,RESULT ?

  SELECT SNO,S1+S2+S3 AS TOTAL,
             (S1+S2+S3)/3 AS SAVG,
             CASE 
             WHEN S1>=35 AND S2>=35 AND S3>=35 THEN 'PASS'
             ELSE 'FAIL'
             END AS RESULT
  FROM STUDENT ;

DECODE() function :- 

 => used to implement IF-THEN-ELSE

   DECODE(expr,value1,return expr1,
               value2,return expr2,
               ---------,
               [default expr])

 UPDATE emp SET sal = DECODE(deptno,10,sal+(sal*0.1), 
                                    20,sal+(sal*0.15),
                                    30,sal+(sal*0.2),
                                    sal+(sal*0.05)
                             )

  diff b/w case & decode ? 

         case                           decode 

  1  supports conditions                 supports only conditions
     based on all operators              based "=" operator

  2  ANSI standard                       not ANSI standard 

 ------------------------------------------------------------------------

28-jan-21 :-

 GROUP BY clause :-  

 => GROUP BY clause is used to group rows based on one or more 
 column to calculate min,max,sum,avg,count for each group.

     EMP
     EMPNO ENAME SAL   DEPTNO
     1	   A	 5000  10
     2	   B	 6000  20			10   9000
     3	   C	 7000  30  -----group by---->	20   8000
     4	   D	 2000  20               	30   7000
     5	   E	 4000  10

      detailed data                             summarized data 

  => GROUP BY clause converts detailed data into summarized data
  which is useful for analysis.

  syntax :-                             Execution :- 

    SELECT columns			FROM
    FROM tabname			WHERE
    [WHERE condition]			GROUP BY
    GROUP BY <colname>			HAVING
    [HAVING condition]			SELECT
    [ORDER BY <colname> [ASC/DESC]]	ORDER BY 

 => display dept wise total salary ? 

    SELECT deptno,SUM(sal)
    FROM emp 
    GROUP BY deptno 
    ORDER BY 1 ASC ;

 FROM emp :- 
 
     EMP
     EMPNO ENAME SAL   DEPTNO
     1	   A	 5000  10
     2	   B	 6000  20			 
     3	   C	 7000  30   
     4	   D	 2000  20               	 
     5	   E	 4000  10
 
 GROUP BY deptno :- 

  10
     1  A   5000
     5  E   4000

  20
     2  B   6000
     4  D   2000

  30
     3  C   7000

  SELECT deptno,SUM(sal) :- 

   10  9000
   20  8000
   30  7000

 2  
    SELECT deptno,ename,SUM(sal)
    FROM emp 
    GROUP BY deptno 
    ORDER BY 1 ASC ;  => ERROR

  NOTE :- only GROUP BY columns and aggregate functions
  should appear in SELECT clause and other than if any column
  appears then it returns error

 3  display job wise no of employees ? 

    SELECT job,COUNT(*)
    FROM emp 
    GROUP BY job ;
    
 4  display year wise no of employees joined ?

   SELECT TO_CHAR(hiredate,'YYYY') as year, 
          COUNT(*)
   FROM emp 
   GROUP BY TO_CHAR(hiredate,'YYYY') 
   ORDER BY 1 ASC ; 

 
   SELECT TO_CHAR(hiredate,'YYYY') as year,
          COUNT(*)
   FROM emp 
   GROUP BY year  => invalid
   ORDER BY year ASC ; => valid

 NOTE :- 

1  column alias cannot be referenced in GROUP BY clause because
  GROUP BY clause is executed before SELECT.

2 column alias can be referenced in ORDER BY clause because 
  ORDER BY clause is executed after SELECT.

29-jan-21 :-

 => display dept wise total sal where deptno=10,20 ? 

    SELECT deptno,SUM(sal)
    FROM emp 
    WHERE deptno IN (10,20)
    GROUP BY deptno 
    ORDER BY 1 ASC ;
 
 => display dept wise total sal where deptno=10,20 and SUM(sal)>10000?

    SELECT deptno,SUM(sal)
    FROM emp 
    WHERE deptno IN (10,20) AND SUM(sal) > 10000
    GROUP BY deptno 
    ORDER BY 1 ASC ;  => ERROR
  
  NOTE :- oracle cannot calculate SUM(sal) of dept before group by
  it can calculate only after group by. so apply the condition
  SUM(sal) > 10000 after group by using HAVING clause.

  
    SELECT deptno,SUM(sal)
    FROM emp 
    WHERE deptno IN (10,20)  
    GROUP BY deptno 
    HAVING SUM(sal) > 10000
    ORDER BY 1 ASC ;

   FROM emp :- 
 
     EMP
     EMPNO ENAME SAL   DEPTNO
     1	   A	 5000  10
     2	   B	 6000  20			 
     3	   C	 7000  30   
     4	   D	 5000  20               	 
     5	   E	 4000  10 

 WHERE deptno IN (10,20) :- 

     EMP
     EMPNO ENAME SAL   DEPTNO
     1	   A	 5000  10
     2	   B	 6000  20			 
     4	   D	 5000  20               	 
     5	   E	 4000  10 

 GROUP BY deptno :- 

  10
      1  A  5000  
      5  E  4000 

  20
     2   B  6000
     4   D  5000

 HAVING SUM(sal) > 10000 :-

  20
     2   B  6000
     4   D  5000
  
 SELECT deptno,SUM(sal) :- 

  20    11000

 
 diff b/w  WHERE and HAVING ? 

            WHERE                         HAVING

     1 selects specific rows             selects specific groups 

     2 conditions applied                conditions applied after
       before group by                   group by 

     3 use WHERE clause if               use HAVING clause if 
       condition doesn't                 conditions contains
       contain aggregate                 aggregate functions 
       functions 

 
 => display job wise no of employees where job=clerk,manager 
 and no of employees > 3 ? 

   SELECT job,COUNT(*)
   FROM emp 
   WHERE job IN ('CLERK','MANAGER') 
   GROUP BY job 
   HAVING COUNT(*) > 3 ; 

 
 => display duplicate records ? 

  EMP22
  ENO  ENAME SAL
  1     A    5000
  2     B    6000
  1     A    5000
  2     B    6000
  3     C    7000

  SELECT eno,ename,sal,count(*)
  FROM emp22
  GROUP BY eno,ename,sal
  HAVING COUNT(*) > 1 ;
  
  => display total salaries deptno,job wise ? 

     SELECT deptno,job,SUM(sal)
     FROM emp 
     GROUP BY deptno,job
     ORDER BY 1 ASC ; 

    10 PRESIDENT 5000
       CLERK     1300
       MANAGER   2450

    20 ANALYST   6000
       CLERK     1900
       MANAGER   2975
  
    30  SALESMAN  5600
  

30-jan-21 :-

  ROLLUP,CUBE :- 

  => both functions are used to calculate subtotals and grand total

            GROUP BY ROLLUP(COL1,COL2,--)
           GROUP BY CUBE(COL1,COL2,---)

 ROLLUP :- 

 => ROLLUP calculates subtotals for each group and also calculates
 grand total.

     SELECT deptno,job,SUM(sal)
     FROM emp 
     GROUP BY ROLLUP(deptno,job)
     ORDER BY 1 ASC ; 

    
    10 PRESIDENT 5000
       CLERK     1300
       MANAGER   2450
                 8750   => dept subtotal

    20 ANALYST   6000
       CLERK     1900
       MANAGER   2975
                 10875  => dept subtotal
  
    30 CLERK     950
       MANAGER   2850 
       SALESMAN  5600
                 9400   => dept subtotal

                 29025  => grand total

 CUBE :- 

 => CUBE calculate subtotals for each group by column i.e. deptno,job
    and also calculates grand total.
 
     SELECT deptno,job,SUM(sal)
     FROM emp 
     GROUP BY CUBE(deptno,job)
     ORDER BY 1 ASC ; 
   
     
     10 PRESIDENT 5000
        CLERK     1300
        MANAGER   2450
                 8750   => dept subtotal

    20 ANALYST   6000
       CLERK     1900
       MANAGER   2975
                 10875  => dept subtotal
  
    30 CLERK     950
       MANAGER   2850 
       SALESMAN  5600
                 9400   => dept subtotal

       ANALYST   6000   => job subtotal
       CLERK     4150   => job subtotal
       MANAGER   8275   => job subtotal
       PRESIDENT 5000   => job subtotal
       SALESMAN  5600   => job subtotal

                 29025  => Grand total
 
scenario :- 

 1 
    SALES
    DATEID    	PRODID   CUSTID  QTY  AMOUNT
    30-JAN-21 	100	 10	 1    5000

   => display year wise and with in year quarter wise total amount 
      and display year wise subtotals ?

     SELECT TO_CHAR(dateid,'YYYY') as year,
            TO_CHAR(dateid,'Q') as qrt,
            SUM(AMOUNT) as total
     FROM sales
     GROUP BY  ROLLUP(TO_CHAR(dateid,'YYYY'),
                      TO_CHAR(dateid,'Q'))
     ORDER BY 1 ; 

  2  PERSONS
     NAME   AGE   GENDER  ADDR   CITY    STATE   AADHARNO
  
 =>    display state wise and with in state gender wise population
       and also display state wise and gender wise subtotals ?

     SELECT STATE,GENDER,COUNT(*)
     FROM PERSONS
     GROUP BY CUBE(STATE,GENDER)
     ORDER BY 1 

   
  => display age group wise  population ? 

      0-20      ?
      21-40     ?
      41-60     ?
      >60       ? 
    
    
    0-1000 
  1001-2000 
  2001-4000
  >4000


  SELECT CASE 
         WHEN SAL BETWEEN 0 AND 1000 THEN '0-1000'
         WHEN SAL BETWEEN 1001 AND 2000 THEN '1001-2000'
         WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
         ELSE 'ABOVE 4000'
         END AS SALRANGE,COUNT(*)
  FROM EMP 
  GROUP BY  CASE 
            WHEN SAL BETWEEN 0 AND 1000 THEN '0-1000'
            WHEN SAL BETWEEN 1001 AND 2000 THEN '1001-2000'
            WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
            ELSE 'ABOVE 4000'
            END 
---------------------------------------------------------------------

01-feb-21 :-

 PIVOT & UNPIVOT operators :- 

 PIVOT operator :- 

 => used to display data in matrix form.
 => used to perform cross tabulation.
 => used to convert rows into columns.

 SELECT *
 FROM (SELECT required data)
 PIVOT
 (expr FOR COL IN (V1,V2,V3,--))
 ORDER BY COL ASC/DESC 

 example 1 :- 
 
	  		 10	20	 30
	
	ANALYST			6000

 	CLERK		1300	1900	 950

	MANAGER		2450	2975	 2850

	SALESMAN			 5600
	
 
 SELECT *
 FROM (SELECT deptno,job,sal FROM emp)
 PIVOT
  (SUM(sal) FOR deptno IN (10,20,30))
 ORDER BY job ASC 
 
 
  2 

      			1	2	3	4


	1980		?	?	?	?

	1981		?	?	?	?

	1982		?	?	?	?

	1983		?	?	?	?


  SELECT *
  FROM (SELECT TO_CHAR(hiredate,'YYYY') as year,
               TO_CHAR(hiredate,'Q') as qrt,
               empno
        FROM emp)
 PIVOT
   (COUNT(empno) FOR qrt IN (1,2,3,4))
 ORDER BY year ASC 

 3 converting rows into columns :- 
 
 CREATE TABLE STUDENT
 (
  SNO NUMBER(2),
  SNAME VARCHAR2(10),
  SUBJECT VARCHAR2(10),
  MARKS NUMBER(3)
 );

 INSERT INTO STUDENT VALUES(&SNO,'&SNAME','&SUB',&MARKS);

  STUDENT
  SNO  SNAME  SUBJECT  MARKS 
  1    A      MAT      80
  1    A      PHY      70
  1    A      CHE      90
  2    B      MAT      70
  2    B      PHY      60
  2    B      CHE      80

 OUTPUT :- 

   SNO  SNAME  MAT   PHY  CHE
   1     A     80    70   90
   2     B     70    60   80
 
 
 SELECT *
 FROM student
 PIVOT
  (SUM(marks) FOR SUBJECT IN ('MAT','PHY','CHE'))
 ORDER BY SNO ASC 

 UnPIVOT :- 

 => reverse process of pivot is unpivot
 => used to convert columns into rows 


   STUDENT
   SNO  SNAME  MAT   PHY  CHE
   1     A     80    70   90
   2     B     70    60   80

  OUTPUT :- 
 
  SNO  SNAME  SUBJECT  MARKS 
  1    A      MAT      80
  1    A      PHY      70
  1    A      CHE      90
  2    B      MAT      70
  2    B      PHY      60
  2    B      CHE      80 
 
  SELECT sno,sname, subject, marks
  FROM Student
  UNPIVOT
  (
	marks
	FOR subject in (MAT,PHY,CHE)
  )  ;


----------------------------------------------------------------------

			 JOINS
                         -----

  => join is an operation performed to combine data stored in 
 multiple tables. To combine data stored in two tables we need
 to join those two tables.

 => in DB tables are normalized i.e. related data stored in 
 multiple tables , to combine or to merge data stored in 
 multiple tables we need to join those tables.

  Example :- 

   ORDERS							 CUSTOMERS
   ORDID   ORD_DT       DEL_DT  	     CID	   CID   CNAME	CADDR
   1000	   20-	    30-	     10	   10		A	  HYD
   1001	   25-	    31-	     11	   11		B	  HYD
   1002	   28-	    02-	     12	   12		C	  HYD


   OUTPUT :-

    ORDID   ORD_DT  DEL_DT   CNAME   CADDR
    1000    20-	    30-	     A       HYD 

  Types of joins :- 
  -----------------
 
   1 Equi Join / Inner Join
   2 Outer Join
   3 Non Equi Join
   4 Self Join
   5 Natural Join
   6 Cross join or Cartisean Join

  02-feb-21 :- 

  Equi Join :- 

  => to perform equi join, between two there must be a common field
 and name of the common field need not to be same.

 => Equi join is performed based on the common field with same datatype.

   SELECT columns
   FROM tabname
   WHERE join condition ; 

  join condition :- 

  => based on the given join condition oracle joins the records of
 two tables.

  => join condition decides which record of table1 should be joined
 with which record of table2. 

     table1.commonfield = table2.commonfield

  => this join is called equi join because here join condition 
 based on "=" operator.

  Example :- 
  
 EMP					DEPT
 EMPNO ENAME SAL   DEPTNO 		DEPTNO	DNAME	    LOC
 1	A    5000  10			10	ACCOUNTS  
 2	B    6000  20			20	RESEARCH
 3	C    4000  30			30	SALES
 4	D    3000  10			40	OPERATIONS 
 5	E    2000  NULL
  

 display ENAME  SAL   DNAME   LOC  ? 
         ----------   -----------
           EMP         DEPT

 SELECT ENAME,SAL,DNAME,LOC
   FROM EMP,DEPT
  WHERE EMP.DEPTNO = DEPT.DEPTNO ;

   A   5000    ACCOUNTS     ???
   B   6000    RESEARCH     ???
   C   4000    SALES        ???
   D   3000    ACCOUNTS     ???
  

 display ENAME  SAL  DEPTNO  DNAME   LOC   ?
  
 SELECT ENAME,SAL,DEPTNO,DNAME,LOC
   FROM EMP,DEPT
  WHERE EMP.DEPTNO = DEPT.DEPTNO ; => ERROR

 => in join queries declare table alias and prefix column names with
 table alias for two reasons 

  1 for faster execution
  2 to avoid ambiguity

 SELECT E.ENAME,E.SAL,D.DEPTNO,D.DNAME,D.LOC AS CITY
   FROM EMP E,DEPT D
  WHERE E.DEPTNO = D.DEPTNO ;

 
 => display employee details working at NEW YORK loc ? 

  SELECT  e.ename,d.dname,d.loc
    FROM  emp e,dept d
   WHERE  e.deptno = d.deptno  /* join cond */
          and
          d.loc='NEW YORK' /* filter cond */ ;

	 joining more than 2 tables :- 
	 ------------------------------
 => when no of tables increases no of join conditions also increases 
to join N tables N-1 join conditions required.

Employees        Departments       Locations         Countries
---------        -----------       ---------         ----------
Employee_id      Department_id     Location_id       Country_id
First_name       Department_name   City              Country_name
Last_name        Location_id       State_province 
Salary                             Country_id
 				          	Department_id
 

 display   ENAME   	DNAME   	CITY   STATE    COUNTRY  ?
           -----   	-----   	-----------     ---------
           Employees    Departments     LOCATIONS       COUNTRIES

  SELECT e.first_name||' '||e.last_name as ename,
         d.department_name as dname,
         l.city,l.state_province as state,
         c.country_name as country
    FROM employees e,
         departments d,
         locations l,
         countries c
   WHERE e.department_id = d.department_id
         and
         d.location_id = l.location_id
         and
         l.country_id = c.country_id ;

 03-FEB-21 :- 

 => we can write join queries in 2 styles 

  1 Native style (oracle style)
  2 ANSI style 

  ANSI style :-  (American National Standard Institute)

  => introduced in oracle 9i.
  => Adv of ANSI style is portability.
  => Native style doesn't gurantee portability but ANSI style 
     gurantees portability.           
  => in ANSI style tablenames are seperated by keywords
  => use ON clause or USING clause for join conditions instead of WHERE clause.

  
 ON clause :-

     display  ENAME   DNAME   ? 

     SELECT e.ename,d.dname
       FROM emp e INNER JOIN dept d 
         ON e.deptno = d.deptno ;

 USING clause :- 

  => USING clause can be used when name of the common field is same.
 
         SELECT e.ename,d.dname
           FROM emp e INNER JOIN dept d 
          USING(deptno);

         SELECT e.ename,d.dname
           FROM emp e INNER JOIN dept d 
          USING(e.deptno);  => ERROR

         
         SELECT e.ename,d.deptno,d.dname
           FROM emp e INNER JOIN dept d 
          USING(deptno);   => ERROR
   
  => columns part of USING clause should not be prefixed with alias.


  => display ENAME,DNAME working at NEW YORK loc ? 

     
       SELECT e.ename,d.dname,d.loc
         FROM emp e INNER JOIN dept d 
           ON e.deptno = d.deptno 
              and
              d.loc='NEW YORK' ;

     SELECT e.ename,d.dname,d.loc
       FROM emp e INNER JOIN dept d 
         ON e.deptno = d.deptno   
      WHERE d.loc='NEW YORK'; 


 => ORACLE recommends  ON clause for join conditions and WHERE clause
 for filter conditions.

 outer join :- 
 -------------- 

 => equi join returns only matching records but cannot return 
 unmatched records but to get unmatched records also perform
 outer join.

 
 EMP						DEPT
 EMPNO ENAME SAL   DEPTNO 		DEPTNO	DNAME	    LOC
 1	A       5000  10			10	ACCOUNTS  
 2	B       6000  20			20	RESEARCH
 3	C       4000  30			30	SALES
 4	D       3000  10			40	OPERATIONS  => unmatched row
 5	E       2000  NULL => unmatched row

 
 => outer join is 3 types 

 1 left outer join
 2 right outer join
 3 full outer join 

 
 Left Outer join :- 
 ------------------

 => returns all rows(matched + unmatched) from left side table and 
    matching rows from right side table.

   SELECT e.ename,d.dname
     FROM emp e,dept d
    WHERE e.deptno = d.deptno(+) ;

 => above query returns all rows from EMP and matching rows from DEPT

       A   ACCOUNTS
       B   RESEARCH
       C   SALES
       D   ACCOUNTS
       E   NULL    => unmatched from EMP

 Right Outer join :- 
 --------------------

 => returns all rows from right side table and matching rows from
 left side table.

  SELECT e.ename,d.dname
    FROM emp e,dept d
   WHERE e.deptno(+) = d.deptno ;

    A   ACCOUNTS
    B   RESEARCH
    C   SALES
    D   ACCOUNTS
   NULL OPERATIONS  => unmatched from dept 

 Full outer join :- 
 --------------------

 => returns all rows from both tables 

  SELECT e.ename,d.dname
    FROM emp e,dept d
   WHERE e.deptno(+) = d.deptno(+) ;  => ERROR

 => Native style doesn't support full outer join , only ANSI style
 supports full outer join. To perform full outer join in Native
  style combine the outputs of left outer and right outer by using
 UNION operator.

   SELECT e.ename,d.dname
     FROM emp e,dept d
    WHERE e.deptno = d.deptno(+) 
    UNION
    SELECT e.ename,d.dname
     FROM emp e,dept d
    WHERE e.deptno(+) = d.deptno ;

   
    A   ACCOUNTS
    B   RESEARCH
    C   SALES
    D   ACCOUNTS
    E   NULL        => unmatched from emp
   NULL OPERATIONS  => unmatched from dept 

  
 ANSI style :- 

 left outer join :- 
 ---------------------

   SELECT e.ename,d.dname
     FROM emp e LEFT OUTER JOIN dept d
       ON e.deptno = d.deptno ;

 right outer join :- 
 ----------------------

   SELECT e.ename,d.dname
     FROM emp e RIGHT OUTER JOIN dept d
       ON e.deptno = d.deptno ;

 full outer join :- 
 ------------------

   SELECT e.ename,d.dname
     FROM emp e FULL OUTER JOIN dept d
       ON e.deptno = d.deptno ;

04-FEB-21 :-

 Display only unmatched records from emp table ? 

   SELECT e.ename,d.dname
     FROM emp e LEFT OUTER JOIN dept d
       ON e.deptno = d.deptno  
    WHERE d.dname IS NULL ;

 Display only unmatched records from dept table ?

 
   SELECT e.ename,d.dname
     FROM emp e RIGHT OUTER JOIN dept d
       ON e.deptno = d.deptno  
    WHERE e.ename IS NULL ;


 Display only unmatched records from both tables ? 

   SELECT e.ename,d.dname
     FROM emp e FULL OUTER JOIN dept d
       ON e.deptno = d.deptno  
    WHERE e.ename IS NULL 
          OR
          d.dname IS NULL ;
 
scenario :-

 PROJECTS
 PROJID   PNAME  DURATION   CLIENT
 100	  A	 5 YEARS    XXXX
 101	  B	 3 YEARS    XXXX
 102	  C	 4 YEARS    XXXX


 EMP
 EMPID	ENAME	SAL	PROJID
 1			100
 2			100
 3			101
 4			NULL


 => display employee details with project details and also display
  employees not assigned to project ? 

   SELECT  e.*,p.*
     FROM  emp e LEFT OUTER JOIN projects p 
       ON  e.projid = p.projid ;

 => display employee details with project details and also display
   projects where no employee assigned to it ? 
 
   SELECT  e.*,p.*
     FROM  emp e RIGHT OUTER JOIN projects p 
       ON  e.projid = p.projid ;


 Non Equi Join :- 
 -----------------

  => Non Equi join is performed when tables are not sharing a common
 field.

 => this join is called non equi join because here join condition 
    is not based on "=" operator.

 Example :-

  EMP                                 SALGRADE
  empno ename  sal                    GRADE  LOSAL  HISAL
  1      A     5000                   1      700     1000
  2      B     1000                   2      1001    2000
  3      C     3000                   3      2001    3000
  4      D     2000                   4      3001    4000
  5      E     1500                   5      4001    9999


   display  ENAME  SAL   GRADE  ? 

   SELECT e.ename,e.sal,s.grade
     FROM emp e,salgrade s
    WHERE e.sal BETWEEN s.losal and s.hisal ; 

     A   5000   5
     B   1000   1
     C   3000   3
     D   2000   2
     E   1500   2

 ANSI style :- 

   
   SELECT e.ename,e.sal,s.grade
     FROM emp e JOIN salgrade s
       ON e.sal BETWEEN s.losal and s.hisal ; 
   

 => display  grade 3 employees list ? 

     SELECT e.ename,e.sal,s.grade
       FROM emp e JOIN salgrade s
         ON e.sal BETWEEN s.losal and s.hisal  
      WHERE s.grade=3 ; 

 => display  ENAME   DNAME    GRADE   ? 
             -----   -----    -------
              EMP    DEPT     SALGRADE 
  
     SELECT e.ename,d.dname,s.grade
       FROM emp e INNER JOIN dept d
         ON e.deptno = d.deptno 
                  JOIN salgrade s
         ON e.sal BETWEEN s.losal and s.hisal ;

 self join :- 
 -------------

 => joining a table to itself is called self join.
 => in self join a record in one table joined with another record of same table
 
Example :- 
----------

   EMP
   EMPNO  ENAME  MGR
   7369   smith  7902
   7499   allen  7698
   7521   ward   7698
   7566   jones  7839
   7698   blake  7839
   7839   king   null
   7902   ford   7566

 => above table contains manager number but to display manager name
   we need to perform self join.

 => to perform self join the same table must be declared two times
 with different alias.

       		  FROM EMP X, EMP Y 

    EMP X                             EMP Y
   EMPNO  ENAME  MGR		      EMPNO	ENAME	MGR
   7369   smith  7902		      7369	smith	7902
   7499   allen  7698		      7499	allen	7698
   7521   ward   7698		      7521	ward	7698
   7566   jones  7839		      7566	jones	7839
   7698   blake  7839		      7698	blake	7839
   7839   king   null		      7839	king	null
   7902   ford   7566		      7902	ford	7566

  
05-feb-21 :- 

    display ENAME,MGRNAME ?

    SELECT x.ename,y.ename as manager
      FROM emp x,emp y
     WHERE x.mgr = y.empno ;

     smith   ford
     allen   blake
     ward    blake
     jones   king
     blake   king
     ford    jones

     display employees reporting to blake ?

      SELECT x.ename,y.ename as manager
        FROM emp x,emp y
       WHERE x.mgr = y.empno  
             AND
             y.ename='BLAKE' ;

     display blake's manager name ?

     
      SELECT x.ename,y.ename as manager
        FROM emp x,emp y
       WHERE x.mgr = y.empno  
             AND
             x.ename='BLAKE' ;

     display employees earning more than their manager ?
     
      SELECT x.ename,x.sal,
             y.ename as manager,y.sal as mgrsal
        FROM emp x,emp y
       WHERE x.mgr = y.empno  
             AND
             x.sal > y.sal ; 

   ANSI style :- 
   ---------------

   display  ENAME   MGRNAME  ?
   
      SELECT x.ename,y.ename as manager 
        FROM emp x JOIN emp y
          ON x.mgr = y.empno ;
   
   display ENAME   DNAME   GRADE    MNAME   ?
           ------  -----   -----    -----
            EMP    DEPT    SALGRADE EMP

          SELECT e.ename,
                 d.dname,
                 s.grade,
                 m.ename
            FROM emp e INNER JOIN dept d
              ON e.deptno = d.deptno
                       JOIN salgrade s
              ON e.sal BETWEEN s.losal and s.hisal 
                       JOIN emp m
              ON e.mgr = m.empno ; 


 scenario :- 

1

 ORGANIZATIONS :- 
 org_id   org_name   		parent_org_id  
 100	  TATA MOTORS HQ			NULL
 101	  TATA MOTORS US           100
 102	  TATA MOTORS IND          100
 103	  TATA MOTORS HYD	     102
 104	  TATA MOTORS NEW YORK	101

 display  org_name   parent_org_name  ? 

 
2  TEAMS
   ID	COUNTRY
   1	IND
   2	AUS
   3	RSA

  write a query to display following output ?

   IND VS AUS
   IND VS RSA
   AUS VS RSA 

  SELECT A.COUNTRY||' VS '||B.COUNTRY
   FROM TEAMS A,TEAMS B
  WHERE A.ID < B.ID 

   TEAMS A                        TEAMS B
   ID	COUNTRY                   ID  COUNTRY
   1	IND                       1   IND
   2	AUS                       2   AUS
   3	RSA                       3   RSA

   IND AUS
   IND RSA
   AUS RSA
   
  cross join or cartisean join :- 
  ------------------------------

  => cross join returns cross product or cartisean product of two tables
 
  A=1,2
  B=3,4
  
  AXB = (1,3) (1,4) (2,3) (2,4) 

 => if cross join performed between two tables then each record of
 1st table joined with each and every record of second table.

 => to perform cross join subquery the query without join condition.

 SELECT e.ename,d.dname
   FROM emp e,dept d ;

 ANSI style :- 

  SELECT e.ename,d.dname
   FROM emp e CROSS JOIN dept d ;
 

-----------------------------------------------------------------------
  
06-FEB-21 :-
------------
 
  => display dept wise total salaries ? 

     SELECT deptno,SUM(sal)
       FROM emp  
   GROUP BY deptno ;
 
  => display dept wise total salaries but display dept names ?
 
      SELECT d.dname,SUM(e.sal)
       FROM  emp e INNER JOIN dept d 
         ON  e.deptno = d.deptno
   GROUP BY  d.dname ; 
  
 Exercise :- 

  SALES
  DATEID       PRODID   CUSTID   QTY   AMOUNT
  05-FEB-21    100      10       1     5000
  
  PRODUCTS
  PRODID   PNAME  PRICE   CATEGORY
  100	   XXXX   5000	  ELECTRONICS

  CUSTOMERS
  CUSTID   CNAME    CADDR   COUNTRY
  10	   XXXX     HYD	    IND


 => display year wise and with in year quarter wise total amount ?

 => display category wise total amount ?

 => display country wise total amount ?

 => display year wise,country wise ,category wise total amount ? 

   SELECT TO_CHAR(S.DATEID,'YYYY') AS YEAR,
          C.COUNTRY,
          P.CATEGORY,
          SUM(S.AMOUNT) AS TOTAL
     FROM SALES S INNER JOIN PRODUCTS P
       ON S.PRODID = P.PRODID
                  INNER JOIN CUSTOMERS C
       ON S.CUSTID = C.CUSTID 
 GROUP BY TO_CHAR(S.DATEID,'YYYY'),C.COUNTRY,P.CATEGORY 
 ORDER BY 1 ;

 ----------------------------------------------------------------------

  08-feb-21 :- 

  SET OPERATORS :-       
  -----------------

 1 union
 2 union all
 3 intersect
 4 minus

 A=1,2,3,4
 B=1,2,5,6

 A UNION B 	= 1,2,3,4,5,6
 A UNION ALL B  = 1,2,3,4,1,2,5,6
 A INTERSECT B  = 1,2
 A MINUS B  	= 3,4
 B MINUS A  	= 5,6

 SELECT STATEMENT 1
 SET OPERATOR
 SELECT STATEMENT 2 ;

 => in DB set operations are performed between set of records return
 by two select statements.

 => no of column return by both queries must be same.

 => corresponding columns datatype must be same.


  SELECT job FROM emp WHERE deptno=20 ;

  CLERK
  MANAGER
  ANALYST
  CLERK
  ANALYST

  SELECT job FROM emp WHERE deptno=30 ;

  SALESMAN
  SALESMAN
  SALESMAN
  MANAGER
  SALESMAN
  CLERK

 
 UNION :- 

  => combines rows return by two select
  => duplicates are eliminated 
  => results is sorted 
  
   SELECT job FROM emp WHERE deptno=20
   UNION
   SELECT job FROM emp WHERE deptno=30 ;

  ANALYST
  CLERK
  MANAGER
  SALESMAN
 
   SELECT job,sal FROM emp WHERE deptno=20
   UNION
   SELECT job FROM emp WHERE deptno=30 ;  => ERROR

   
   SELECT job,sal FROM emp WHERE deptno=20
   UNION
   SELECT sal,job FROM emp WHERE deptno=30 ; => ERROR

    diff b/w union & join   ? 

      UNION                         JOIN 

  1  horizontal merge              vertical merge

  2  combines rows                 combines columns 

  3  performed between two         performed between two dissimilar
     similar structures             structures

 Example :- 

 T1	T2
 F1	F1
 1	4
 2	5
 3	6

 T1 U T2 :- 

 1
 2
 3 
 4
 5
 6

 T1 JOIN T2 :- 

 1   4
 2   5
 3   6
 
 scenario :- 

 EMP_US
 ENO	ENAME	SAL	DNO
 
					DEPT
 EMP_IND				DNO	DNAME	LOC
 ENO	ENAME	SAL	DNO
 
 
 1 total employees list ? 

  SELECT * FROM EMP_US
  UNION
  SELECT * FROM EMP_IND ; 

 2 display employee list working at US loc with dept details ?

   SELECT E.*,D.*
     FROM  EMP_US E INNER JOIN DEPT D
       ON  E.DNO = D.DNO ; 

 3 display total employees with dept details ? 

 method 1 :-

   SELECT E.*,D.*
     FROM  EMP_US E INNER JOIN DEPT D
       ON  E.DNO = D.DNO 
   UNION
   SELECT E.*,D.*
     FROM  EMP_IND E INNER JOIN DEPT D
       ON  E.DNO = D.DNO ;

   
 method 2 :- 

  SELECT E.*,D.*
    FROM (SELECT * FROM EMP_US
          UNION
          SELECT * FROM EMP_IND) E INNER JOIN DEPT D
      ON E.DNO = D.DNO ;

 UNION ALL :- 
 ------------

 => combines rows return by two select statements
 => duplicates are not eliminated
 => result is not sorted 

  diff b/w UNION & UNION ALL ?

         UNION                   UNION ALL 
 
  1   eliminates duplicates      doesn't eliminate duplicates
  2   result is sorted           result is not sorted 
  3   slower                     faster

   SELECT job FROM emp WHERE deptno=20
   UNION ALL
   SELECT job FROM emp WHERE deptno=30 ;
  
   CLERK
   MANAGER
   ANALYST
   CLERK
   ANALYST
   SALESMAN
   SALESMAN
   SALESMAN
   MANAGER
   SALESMAN
   CLERK
    
  INTERSECT :- 
  -------------

  => returns common values from the output of two select statements.

    SELECT job FROM emp WHERE deptno=20
    INTERSECT
    SELECT job FROM emp WHERE deptno=30; 
 
    CLERK
    MANAGER

  MINUS :- 
  --------

 => returns values present in 1st query output and not present in
  2nd query output.

  SELECT job FROM emp WHERE deptno=20
  MINUS
  SELECT job FROM emp WHERE deptno=30 ;

  ANALYST 

  SELECT job FROM emp WHERE deptno=30
  MINUS
  SELECT job FROM emp WHERE deptno=20 ;

  SALESMAN 

 ---------------------------------------------------------------------

 09-FEB-21 :-

  SUB-QUERIES :- 
  --------------
  
 => a query in another query is called sub-query or nested query.
 => one query is called inner/child/sub-query
 => other query is called outer/parent/main query.
 => first oracle executes inner query then oracle executes outer query
 => result of inner query is input to outer query
 => use subquery when where condition based on unknown value

  Types of subqueries :- 
  ----------------------

  1 single row subqueries
  2 multi row subqueries
  3 co-related subqueries
  4 inline views
  5 scalar subqueries 


 1 single row subqueries :- 
 ---------------------------

  => if inner query returns one value then it is called single row
 subquery.

  SELECT columns	
  FROM tabname
  WHERE colname OP (SELECT STATEMENT) ;

 Examples :- 
 ----------

 1  display employees earning more than blake ?

   SELECT *
   FROM emp 
   WHERE sal > (SELECT sal FROM emp WHERE ename='BLAKE')  


 2  display employees who are senior to king ?

    SELECT ename,hiredate
    FROM emp
    WHERE hiredate < (SELECT hiredate FROM emp WHERE ename='KING')

 3  display employee name earning max salary ?

    SELECT ename
    FROM emp 
    WHERE sal = MAX(sal) ;  => ERROR

  NOTE :- max,min,sum,avg,count functions are not allowed in where
  clause they are allowed only in SELECT,HAVING clauses.

   SELECT ename
   FROM emp 
   WHERE sal = (SELECT MAX(sal) FROM emp) ;

 4 display employee name having max experience ?

  SELECT ename
  FROM emp 
  WHERE hiredate = (SELECT MIN(hiredate) FROM emp) ;

 
 5  display 2nd max salary ?

    SELECT MAX(sal) 
    FROM emp
    WHERE sal < (SELECT MAX(sal) FROM emp);
 
 6  display name of the employee earning 2nd max sal ?

    SELECT ename
    FROM emp 
    WHERE sal = (SELECT MAX(sal) 
                 FROM emp
                 WHERE sal < (SELECT MAX(sal) FROM emp));

  NOTE :- queries can be nested more than one level and can be 
  nested upto 255 level.
 
  => outer query can be SELECT/INSERT/UPDATE/DELETE but inner query
  must be always SELECT.

  7 update employee sal to max(sal) of 30th dept whose empno=7499 ?

    UPDATE emp
    SET sal = (SELECT MAX(sal) FROM emp WHERE deptno=30)
    WHERE empno=7499 ; 

  8 swap employee salaries where empno=7369,7499 ?

    UPDATE emp 
    SET sal = CASE empno
              WHEN 7369 THEN (SELECT sal FROM emp WHERE empno=7499)
              WHEN 7499 THEN (SELECT sal FROM emp WHERE empno=7369)
              END 
    WHERE empno IN (7369,7499);

  10-feb-21 :-
        
 9 find the dept where maximum no of employees working ? 

   SELECT deptno
   FROM emp 
   GROUP BY deptno
   HAVING count(*) = (SELECT MAX(COUNT(*))
                      FROM emp
                      GROUP BY deptno);

   
 10 in which year maximum no of employees joined ? 

 join vs subquery :- 
 -------------------

1 display employee details working at NEW YORK loc ?

 join :- 

  SELECT e.*
  FROM emp e INNER JOIN dept d
    ON e.deptno = d.deptno
  WHERE d.loc='NEW YORK' ; 

         
 subquery :- 

 SELECT empno,ename,sal,deptno
 FROM emp
 WHERE deptno = (SELECT deptno FROM dept WHERE loc='NEW YORK');

 
2  display employee details with dept details working at NEW YORK loc ?

 join :-

  SELECT e.empno,e.ename,e.sal,d.dname,d.loc
  FROM emp e INNER JOIN dept d
    ON e.deptno = d.deptno
  WHERE d.loc='NEW YORK';

 subquery :- 

  not possible

-
 => to display data from one table and condition based on another
 table then use join or subquery.

 => to display data from two tables then use join operation.

multi-row subqueries :- 
-----------------------

=> if inner query returns more than one value then it is called
 multi row subquery.

  SELECT columns
  FROM tabname
  WHERE colname OP (SELECT STATEMENT) 

  => OP must be IN,NOT IN,ANY,ALL.

 Example 1 :- 

  display employees whose job = job of smith ,blake ?

  SELECT *
  FROM emp
  WHERE job IN (SELECT job FROM emp WHERE ename IN ('SMITH','BLAKE'));

11-feb-21 :-

 ROWNUM :- 
 ----------

 => returns record numbers for the records return by select statement.

 => ROWNUM is called psuedo column because it is not a column but
    acts like a column.

   SELECT ROWNUM,empno,ename,sal FROM emp ; 

     10   king

   SELECT ROWNUM,empno,ename,sal FROM emp WHERE sal>=2000 ;
   
     6    king

   SELECT ROWNUM,empno,ename,sal FROM emp WHERE sal>=3000 ;  

     3    king

   => rownum is not based on table it is based on select statement
    output, if select stmt output changes rownum also changes.

   => rownum is useful when fetching records from table is based on
  record numbers.

   => display first 5 rows from emp ? 

      SELECT * FROM emp WHERE ROWNUM <= 5 ;

   => display 5th row ?

     SELECT * FROM emp WHERE ROWNUM = 5; 

   NOTE :-  in where conditions with rownum  =  >   >= will not work
   only  <   <= will work.

    SELECT * FROM emp WHERE ROWNUM <= 5 
    MINUS
    SELECT * FROM emp WHERE ROWNUM <= 4 ;
  
  => display 5th,7th,11th ?

    SELECT CASE ROWNUM
           WHEN 5 THEN empno
           WHEN 7 THEN empno
           WHEN 11 THEN empno
           END as empno
    FROM emp ; 

   => above query displays only EMPNO but to display complete row
    
     SELECT *
     FROM emp 
     WHERE empno IN (SELECT CASE ROWNUM
                           WHEN 5 THEN empno
                           WHEN 7 THEN empno 
                           WHEN 11 THEN empno 
                           END as empno
                    FROM emp);

 => display even no rows ? 

    SELECT *
    FROM emp
    WHERE empno IN (SELECT CASE MOD(ROWNUM,2)
                           WHEN 0 THEN empnO
                           END as empno
                    FROM emp)

 => display 5th to 10th record ?

    SELECT *
    FROM emp 
    WHERE empno IN (SELECT CASE 
                           WHEN ROWNUM BETWEEN 5 AND 10 THEN empnO
                           END as empno
                    FROM emp) ;

 => display Mth to Nth record ?

    SELECT *
    FROM emp 
    WHERE empno IN (SELECT CASE 
                          WHEN ROWNUM BETWEEN &M AND &N THEN empnO
                          END as empno
                    FROM emp) ;

 => display last 3 rows ? 


 12-FEB-21 :- 
 ------------

 co-related subqueries :- 
 --------------------------

 => if inner query refers values of outer query then it is called
 co-related subquery.

 => here execution starts from outer query and inner query is 
 executed multiple times depends on no of rows return by outer query

 => use co-related subquery to execute subquery for every row 
 return by outer query.

 1 returns a row from outer query
 2 pass value to inner query
 3 executes inner query
 4 returns a value to outer query
 5 execute outer query where condition.

 Example 1 :- 

  EMP
  EMPNO ENAME SAL   DEPTNO
  1     A     5000  10
  2     B     3000  20
  3     C     4000  30
  4     D     3000  10
  5     E     6000  20

 => display employees earning more than avg(sal) of their dept ?

    SELECT empno,ename,sal,deptno,
                 (SELECT AVG(sal) FROM emp WHERE deptno=x.deptno)
                      as avgsal
    FROM emp x
    WHERE sal > (SELECT AVG(sal) FROM emp WHERE deptno=x.deptno);

   
   1     A     5000  10    5000 > (4000)   TRUE
   2     B     3000  20    3000 > (4500)   FALSE
   3     C     4000  30    4000 > (4000)   FALSE
   4     D     3000  10    3000 > (4000)   FALSE
   5     E     6000  20    6000 > (4500)   TRUE

  Example 2 :- 
 
  => display employees earning max sal in their dept ?

     SELECT empno,ename,sal,deptno
     FROM emp x
     WHERE sal = (SELECT MAX(sal) FROM emp WHERE deptno=x.deptno);
    
      1     A     5000  10   5000 = (5000)   TRUE
      2     B     3000  20   3000 = (6000)   FALSE

 Example 3 :- 

   display top 3 maximum salaries ? 

   A              B
   SAL            SAL     
   5000           5000        3 > (0)   TRUE
   1000           1000        3 > (4)   FALSE
   3000           3000        3 > (2)   TRUE
   2000           2000        3 > (3)   FALSE
   4000           4000        3 > (1)   TRUE
   
   SELECT  DISTINCT A.SAL
   FROM EMP A
   WHERE 3 > (SELECT COUNT(DISTINCT B.SAL)
              FROM EMP B
              WHERE A.SAL < B.SAL) 
   ORDER BY SAL DESC ;
 
   display 3rd maximum salary ?

   SELECT  DISTINCT A.SAL
   FROM EMP A
   WHERE (3-1) =  (SELECT COUNT(DISTINCT B.SAL)
                   FROM EMP B
                   WHERE A.SAL < B.SAL) 
   ORDER BY SAL DESC ;

   display Nth maximum salary ?

   SELECT  DISTINCT A.SAL
   FROM EMP A
   WHERE (&N-1) =  (SELECT COUNT(DISTINCT B.SAL)
                    FROM EMP B
                    WHERE A.SAL < B.SAL) 
   ORDER BY SAL DESC ;
 

 13-FEB-21 :- 

   ROWID :- 
   ---------
   
   =>  returns physical address of a row
   =>  psuedo column because it is not a column but acts like a column
   
     SELECT ROWID,empno,ename,sal FROM emp ;
 
   => rowids are the fastest way to fetch data from table

     SELECT * FROM emp WHERE rowid = '-------------------' ;

   => ROWIDs are used to delete duplicate records.

 Example :-

   EMP33
   ENO  ENAME  SAL     ROWID
   1    A      5000    AAA
   2    B      6000    AAB
   3    C      7000    AAC   
   1    A      5000    AAD
   2    B      6000    AAE
       

  => delete duplicate records in emp33 table ?

     DELETE FROM EMP33 WHERE ROWID LIKE '%AAD' ; 

     DELETE FROM EMP33 WHERE ROWID LIKE '%AAE' ;

  => deleting duplicates row-by-row is difficult if table contains
  huge number of duplicate rows. so execute the following query
  to delete all duplicate rows from table.

  DELETE FROM emp33 x
    WHERE ROWID <> (SELECT MIN(ROWID)
                    FROM emp33
                    WHERE eno = x.eno
                          and
                          ename=x.ename
                          and
                          sal=x.sal);

1    A      5000    AAA <> (AAA)   NOT DELETED
2    B      6000    AAB <> (AAB)   NOT DELETED
3    C      7000    AAC <> (AAC)   NOT DELETED
1    A      5000    AAD <> (AAA)   DELETED
2    B      6000    AAE <> (AAB)   DELETED 

15-FEB-21 :-

EXISTS operator :- 

 => used to check whether record exists in the table or not

   SELECT columns
   FROM tabname
   WHERE EXISTS (SELECT statement) ;

 => EXISTS returns TRUE or FALSE

 => if subquery returns atleast one row then exists returns true
 => if subquery returns 0 rows then exists returns false

scenario :-

 DEPTNO
 DEPTNO  DNAME   LOC
 10	    ACCT
 20      RESEARCH
 30      SALES
 40      OPERATIONS

 EMP
 EMPNO	ENAME	SAL	DEPTNO
  1			10
  2			20
  3			30
  4			10
  5			20

 => display departments which are not empty ?

   SELECT *
   FROM DEPT X
   WHERE EXISTS (SELECT * FROM EMP WHERE DEPTNO=X.DEPTNO);

   SELECT *
   FROM DEPT
   WHERE DEPTNO IN (SELECT DEPTNO FROM EMP);

                    10
                    20
                    30
                 
  NOTE :- oracle recommends EXISTS operator than IN operator because
  EXISTS gives good performance than IN because comparision with
  TRUE/FALSE is much faster than comparision with values.

 NOT EXISTS :- 
 -------------

   SELECT columns
   FROM tabname
   WHERE NOT EXISTS (SELECT statement) ;

 => NOT EXISTS also returns TRUE / FALSE 

   TRUE  => if subquery returns 0 rows 
   FALSE => if subquery returns atleast one row

  scenario :-

 DEPT 
 DEPTNO  DNAME   LOC
 10	 ACCT
 20      RESEARCH
 30      SALES
 40      OPERATIONS

 EMP
 EMPNO	ENAME	SAL	DEPTNO
  1			10
  2			20
  3			30
  4			10
  5			20

 => display departments which are empty ?

   SELECT *
   FROM DEPT X
   WHERE NOT EXISTS (SELECT * FROM EMP WHERE DEPTNO=X.DEPTNO);

   
   SELECT *
   FROM DEPT
   WHERE DEPTNO NOT IN (SELECT DEPTNO FROM EMP);

                  	  10
                  	  20
                  	  30

 NOTE :- oracle recommends NOT EXISTS operator than NOT IN operator
 because NOT EXISTS gives good performance than NOT IN operator.

 INLINE views :- 
 ----------------

 => subqueries in FROM clause are called INLINE views.

   SELECT columns
   FROM (SELECT STATEMENT) <alias>
   WHERE condition ;

   
 => subquery output acts like a table for outer query.

 => INLINE views are used in following scenarios

  1 to control order of execution of clauses
  2 to use the query output in join operation
  3 to use the result of one process in another process

 controlling order of execution of clauses :- 
 ---------------------------------------------

 => by default oracle executs clauses in the following order

  FROM
  WHERE
  GROUP BY
  HAVING
  SELECT
  ORDER BY 

 => use INLINE views to control order of execution

 Example 1 :- 

   display ename,annual salary ? 

   SELECT ename,sal*12 as annsal
   FROM emp ; 

  => above query display all the employees annual salaries but
   to display employees whose annual sal > 30000 ?

   SELECT ename,sal*12 as annsal
   FROM emp  
   WHERE annsal > 30000 ;  => ERROR

  => column alias cannot be referenced in where clause because
 where clause is executed before select clause. To overcome this
 problem use INLINE views.

  SELECT *
  FROM (SELECT ename,sal*12 as annsal
        FROM emp) e
  WHERE annsal > 30000; 
  
 Example 2 :- 
 ------------

  display employee ranks based on sal and highest paid employee
  should get 1st rank ? 

  SELECT empno,ename,sal,
         dense_rank() over (order by sal desc) as rnk
  FROM emp ;

  => display only top 5 employees ?

  SELECT empno,ename,sal,
         dense_rank() over (order by sal desc) as rnk
  FROM emp 
  WHERE rnk <= 5 ;  => ERROR

  SELECT *
  FROM  (SELECT empno,ename,sal,
          dense_rank() over (order by sal desc) as rnk
        FROM emp) E
  WHERE rnk <= 5 ; 

  => display 5th max salary ?

  SELECT DISTINCT sal
  FROM  (SELECT sal,
          dense_rank() over (order by sal desc) as rnk
        FROM emp) E
  WHERE rnk = 5 ; 

 
16-feb-21 :- 

 display first 5 rows from emp ?

 SELECT rownum as rno,empno,ename,sal 
 FROM emp 
 WHERE rownum <=5 ;

 display 5th row ?

 SELECT rownum as rno,empno,ename,sal 
 FROM emp 
 WHERE rownum=5 ; => no rows 

 SELECT *
 FROM (SELECT rownum as rno,empno,ename,sal FROM emp) E
 WHERE rno = 5 ;

 WHERE rno IN (5,7,11);

 WHERE rno BETWEEN 5 AND 10; 

 WHERE MOD(rno,2)=0;

 
 12C :- 

 FETCH clause :- used to limit no of rows return by select statement

 display first 5 rows ?

 SELECT empno,ename,sal
 FROM emp
 FETCH FIRST 5 ROWS ONLY ; 

 display 5th row ?

  SELECT empno,ename,sal
  FROM emp
  OFFSET 4 ROWS FETCH NEXT 1 ROW ONLY ; 

 display 5th row to 10th row ?

  SELECT empno,ename,sal
  FROM emp
  OFFSET 4 ROWS FETCH NEXT 6 ROWS ONLY ; 

 display top 5 maximum salaries ? 

 SELECT DISTINCT sal
 FROM emp 
 ORDER BY sal DESC
 FETCH FIRST 5 ROWS ONLY ;


 METHOD 1 :- 

 SELECT DISTINCT a.sal
 FROM emp a
 WHERE 3 > (SELECT COUNT(B.sal)
            FROM emp b
            WHERE a.sal < b.sal);
 

METHOD 2 :- 

 SELECT DISTINCT sal
 FROM (SELECT sal,dense_rank() over (order by sal desc) as rnk
       FROM emp) E
 WHERE rnk<=5 ;


METHOD 3 :- 

 SELECT DISTINCT sal
 FROM emp 
 ORDER BY sal DESC
 FETCH FIRST 5 ROWS ONLY ;

scalar subqueries :- 
---------------------

 => subqueries in SELECT clause are called scalar subqueries.

   SELECT (subquer1),(subquer2),----------
   FROM tabname
   WHERE condition ;

 => subquery output acts like a column.

 => use scalar subquery to show the query output in seperate columns

  Example 1 :- 

    display  emp     dept    ?
             ?        ?
 
    SELECT (SELECT COUNT(*) FROM emp) as emp,
           (SELECT COUNT(*) FROM dept) as dept
    FROM DUAL ; 

    
   Example 2 :- 

    display deptno,dept_totsal,totsal ?
    
    SELECT deptno,SUM(sal) AS DEPT_TOTSAL,
             (SELECT SUM(sal) FROM emp) AS TOTSAL
    FROM emp 
    GROUP BY deptno 
    ORDER BY deptno ASC ;

    display deptno,dept_totsal,totsal,pct ?

     pct :-  (dept_totsal/totsal)*100 

    SELECT deptno,SUM(sal) AS DEPT_TOTSAL,
             (SELECT SUM(sal) FROM emp) AS TOTSAL,
    ROUND((SUM(sal)/(SELECT SUM(sal) FROM emp))*100) AS PCT
    FROM emp 
    GROUP BY deptno 
    ORDER BY deptno ASC ;

----------------------------------------------------------------------

 18-feb-21 :- 

 Database Transactions :- 
 ------------------------

 => a Transaction is a unit of work that contains one or more dmls
    and it must be saved as a whole or must be cancelled as a whole.

         acct1----------------------->acct2

         update(-)                    update(+)
         
         successful                   failed       invalid
         failed                       successful   invalid

         successful                   successful   valid
         failed                       failed       valid


  => if txn contains multiple operations if all operations are 
 successful then it must be saved if one of the operation fails
 then entire txn must be cancelled because every txn must gurantee
 a property called atomocity i.e. all or none.

 => the following commands provided by oracle to handle transactions
    called TCL(Transaction Control Language) commands.

        1 commit        => to save txn
        2 rollback      => to cancel txn
        3 savepoint     => to cancel part of the txn

   
 => every txn has a begin point and an end point

 =>  a txn begins when user submits DML command to oracle and
     
 => a txn ends when user submits any of the following command

   1 commit / rollback
   2 ddl command txn ends with commit


  UPDATE1  => txn begins T1
  INSERT1
  UPDATE1
  INSERT1
  COMMIT   => txn ends 


 => if txn ends with commit then it is called successful txn and
    operations are saved 

  UPDATE1  => txn begins T1
  INSERT1
  UPDATE1
  INSERT1
  ROLLBACK  => txn ends 

  => if txn ends with rollback then it is called aborted txn and
 operations are cancelled.

 Example 1 :- 
 
  create table a(a number);  => commit 
  insert into a values(10);  => txn begins t1
  insert into a values(20);
  insert into a values(30);
  insert into a values(40);
  insert into a values(50);
  rollback;                  => txn ends    

 
  create table   => saved
  inserts        => cancelled


 Example 2 :- 

  create table a(a number);   => commit 
  insert into a values(10);   => txn begins T1
  insert into a values(20);
  insert into a values(30);    
  create table b(b number);   => T1 ends with commit
  insert into a values(40);   => txn begins T2
  insert into a values(50);
  rollback;                   => T2 ends with rollback
  
  output :- 
 
  create table a,b   => saved
  insert 10,20,30    => saved
  insert 40,50       => cancelled

  savepoint :- 
  -------------

  => we can declare savepoint and we can cancel txn upto the savepoint
  => using savepoint we can cancel part of the txn.

      savepoint <name> 

      savepoints sp1;

 Example 1 :-

     create table a(a number);   
     insert into a values(10);   
     insert into a values(20);
     savepoint sp1;
     insert into a values(30);
     insert into a values(40);
     savepoint sp2;
     insert into a values(50);
     insert into a values(60);
     rollback to sp2 ;

     SELECT * FROM A ;
 
     10
     20
     30
     40 
     
  Example 2 :-

     create table a(a number);   
     insert into a values(10);   
     insert into a values(20);
     savepoint sp1;
     insert into a values(30);
     insert into a values(40);
     savepoint sp2;
     insert into a values(50);
     insert into a values(60);
     rollback to sp1 ;

     SELECT * FROM A ;

     10
     20 

 summary :- 

  commit :- 

  1 saves transaction
  2 changes db state
  3 releases locks 

  rollback :- 

  1 cancels transaction
  2 doesn't change db state
  3 releases locks 


 ---------------------------------------------------------------------

19-FEB-21 

 Database Security :- 
 --------------------

 1  users         => provides security at db level
 2  privileges    => provides security at table level
 3  views         => provides security at row & col level

 DB
   TABLES
      ROWS & COLS

 creating user / schema :- 
 -------------------------

 => users are created by DBA 

 step 1 :- conn as SYSTEM/MANAGER

 step 2 :- create user 

 syntax :-

  CREATE USER <NAME> IDENTIFIED BY <PWD>
  DEFAULT TABLESPACE USERS
  QUOTA UNLIMITED ON USERS ; 

 example :- 

  CREATE USER SCOTT IDENTIFIED BY TIGER
  DEFAULT TABLESPACE USERS
  QUOTA UNLIMITED ON USERS ;

 => a user is created with name SCOTT but user doesn't have permissions
  to connect to oracle and to create tables.

 => grant permissions to user by using GRANT command.

 step 3 :- 

   GRANT CONNECT,RESOURCE TO SCOTT ;

        CONNECT  => to connect to db
        RESOURCE => to create objects 
        DBA      => all permissions 
   
 PRIVILEGES :- 
 --------------

  => privileges means permissions 
  => permissions are granted by using GRANT command
 
  syn :- GRANT <permissions> ON <tabname> TO <usernames> 

  ex :- 

  BATCH7AM :- 
 
  GRANT ALL ON EMP TO SCOTT; 

ALL :-

  1 SELECT
  2 INSERT
  3 UPDATE
  4 DELETE
  5 ALTER
  6 READ
  7 FLASHBACK
  8 DEBUG
  9 ON COMMIT REFRESH
  10 QUERY REWRITE
  11 REFERENCES
  12 INDEX 

  SCOTT :- 
 
 1  SELECT * FROM BATCH7AM.EMP;

 2  UPDATE BATCH7AM.EMP SET SAL=2000 WHERE EMPNO=7369; 

  => changes made by one user visible to another user after commit.

 Granting specific privileges :- 
 ---------------------------------

 BATCH7AM :- 
 -----------

 GRANT SELECT,INSERT,UPDATE ON DEPT TO SCOTT ; 

 SCOTT :- 

 1 SELECT * FROM BATCH7AM.EMP ;

 2 DELETE FROM BATCH7AM.EMP WHERE DEPTNO=10; => ERROR

 Granting permissions to multiple users :- 
 -----------------------------------------

 BATCH7AM :- 
 ------------

 GRANT ALL ON EMP TO SCOTT,HR,SH ; 
  

 Granting permissions to all users :-
 -------------------------------------

   GRANT ALL ON EMP TO PUBLIC ;

 
  BATCH7AM-----EMP------>SCOTT----EMP-------->VIJAY

  GRANTOR               GRANTEE    not possible

 NOTE :- grantee cannot grant permissions to another user

 WITH GRANT OPTION :- 
 --------------------

 => if permissions granted with grant option then grantee can also
 grant permissions another user.

 BATCH7AM :- 

  GRANT ALL ON EMP TO SCOTT WITH GRANT OPTION ;

 SCOTT :- 

  GRANT ALL ON BATCH7AM.EMP TO HR ;

  HR :- 

  SELECT * FROM BATCH7AM.EMP ;

 REVOKE command :- 
 -----------------

 => command used to take back permissions from user.

   REVOKE <privileges> ON <tabname> FROM <usernames>; 
 
  Ex :- 

  BATCH7AM :- 

  REVOKE ALL ON EMP FROM SCOTT ;

  SCOTT :-

  SELECT * FROM BATCH7AM.EMP;  => ERROR

  USER_TAB_PRIVS_MADE :- 
 
  => stores information about privileges granted to users.
  => used by grantor

   SELECT TABLE_NAME,PRIVILEGE,GRANTEE
   FROM USER_TAB_PRIVS_MADE 
   ORDER BY TABLE_NAME ASC ;

 USER_TAB_PRIVS_RECD :- 

 => stores information about privileges recieved.
 => used by grantee
                
----------------------------------------------------------------------
22-feb-21 
	
Integrity Constraints :-
------------------------

=> Integrity constraints are rules to maintain 
   Data Integrity i.e. Data Quality.

=> Integrity Constraints prevents users from entering
  invalid data.

=> Integrity Constraints enforce  rules like min
  bal must be 1000.

 Types of Constraints :- 
 -----------------------

 1 Not Null
 2 Unique
 3 Primary Key
 4 Check
 5 Foreign key
 6 Default

  => above constraints are declared in two ways 

  1 column level
  2 table level

 column level :- 

 => if constraints are declared immediately after declaring 
   column then it is called column level.

  CREATE TABLE <TABNAME>
  (
    COLNAME  DATATYPE(SIZE) CONSTRAINT,
    COLNAME  DATATYPE(SIZE) CONSTRAINT,
    ------------------------
   );
 
 NOT NULL :- 
 -----------

 => not null constraint doesn't accept null values.
 => a column declared with NOT NULL is called mandatory column 

 Example :- 

  CREATE TABLE EMP11
   (
    EMPNO  NUMBER(4),
    ENAME  VARCHAR2(10) NOT NULL
   );

 Testing :- 

   INSERT INTO EMP11 VALUES(100,'A');
   INSERT INTO EMP11 VALUES(101,''); => ERROR

 UNIQUE :- 
 ----------

 => unique constraint doesn't accept duplicates 

 CREATE TABLE CUST
  (
    cid      number(2),
    cname    varchar2(10),
    emailid  varchar2(30) UNIQUE);

 Testing :- 

  INSERT INTO CUST VALUES(10,'A','abc@gmail.com');
  INSERT INTO CUST VALUES(11,'B','abc@gmail.com'); => ERROR
  INSERT INTO CUST VALUES(12,'C','');   => 1 row created            
  INSERT INTO CUST VALUES(13,'D','');   => 1 row created

 NOTE :- UNIQUE constraint allows NULLs

 PRIMARY KEY :- 
 --------------

 => primary key doesn't accept duplicates and nulls
 => it is the combination of UNIQUE & NOT NULL.
 
        PRIMARY KEY = UNIQUE + NOT NULL 

 CREATE TABLE EMP12
 (
   EMPNO  NUMBER(4) PRIMARY KEY,
   ENAME  VARCHAR2(10)
  );

Testing :- 

  INSERT INTO EMP12 VALUES(100,'A');
  INSERT INTO EMP12 VALUES(100,'B');    => ERROR
  INSERT INTO EMP12 VALUES(NULL,'B');   => ERROR

  
 => using PRIMARY KEY we can uniquely identify records 
   in a table.

 => only one primary key is allowed per table , if we want two 
 primary keys then declare one column with primary key and another
 column with UNIQUE & NOT NULL.

  
 CREATE TABLE CUST
 (
   ACCNO  NUMBER(11)    PRIMARY KEY,
   NAME   VARCHAR2(10)  NOT NULL,
   AADHARNO  NUMBER(12) UNIQUE NOT NULL
  );


 CHECK :- 
 ---------

 => use check constraint when rule based on condition 

        syn :- CHECK(condition) 

  Example 1 :- sal must be min 3000 

   CREATE TABLE EMP13
   (
     EMPNO NUMBER(4),
     SAL NUMBER(7) CHECK(SAL>=3000)
   );

  Testing :- 

 1   INSERT INTO EMP13 VALUES(100,1000); => ERROR

 2   INSERT INTO EMP13 VALUES(101,5000);

 3   INSERT INTO EMP13 VALUES(102,NULL);


 NOTE :- 

  1  CHECK CONSTRAINT ALLOWS NULLS
  2  IN CHECK CONSTRAINT SYSTEM VARIABLES LIKE SYSDATE ARE NOT ALLOWED

 Example 2 :- GENDER must be 'M','F' ? 

      GENDER CHAR(1)  CHECK(GENDER IN ('M','F'))

 Example 3 :- amt must be multiple of 100 

      AMT NUMBER(6) CHECK(MOD(AMT,100)=0) 

 Example 4 :- PWD must be min 8 chars ? 

      PWD VARCHAR2(20) CHECK(LENGTH(PWD)>=8))

23-feb-21

FOREIGN KEY :- 
--------------

 => foreign key is used to establish relationship between two tables.

 => to establish relationship between two tables , take pk of one
 table and add it to another table as fk and declare with references
 cosntraint.

 Example :- 

  DEPT
  DEPTNO   DNAME   CITY
  10       HR      MUM
  20       IT      HYD
  30       SALES   BLR


  EMP
  EMPNO  ENAME  SAL    DEPTNO   REFERENCES DEPT(DEPTNO) 
  1      A      5000    10
  2      B      6000    20
  3      C      7000    90   => invalid
  4      D      4000    10   => valid
  5      E      3000    null => valid

  
 => values entered fk column should match with values entered in 
 pk column.

 => fk allows duplicates and nulls.

 => after declaring fk  a relationship is established between two
 tables called parent/child relationship.

 => pk table is parent and fk table is child.

  Example 1 :- 

   CREATE TABLE DEPT55
    (
      DEPTNO NUMBER(2) PRIMARY KEY,
      DNAME  VARCHAR2(10) UNIQUE NOT NULL,
      CITY   CHAR(3) 
   ); 

   INSERT INTO DEPT55 VALUES(10,'HR','MUM');
   INSERT INTO DEPT55 VALUES(20,'IT','HYD');
  
   CREATE TABLE EMP55
    (
      EMPNO  NUMBER(4) PRIMARY KEY,
      ENAME  VARCHAR2(10) NOT NULL,
      SAL    NUMBER(7,2) CHECK(SAL>=3000),
      DEPTNO NUMBER(2) REFERENCES DEPT55(DEPTNO)
    );
  

   Testing :- 

  1 INSERT INTO EMP55 VALUES(1,'A',5000,10);
  2 INSERT INTO EMP55 VALUES(2,'B',4000,90); => ERROR
  3 INSERT INTO EMP55 VALUES(3,'C',3000,10);
  4 INSERT INTO EMP55 VALUES(4,'D',4000,NULL);

 => by default oracle creates 1:M relationship 
    between two tables , to establish 1:1 relationship
    declare fk with unique constraint.

 Example 2  :- (1:1 relationship)
 ------------

  DEPT
  DEPTNO   DNAME   CITY
  10       HR      MUM
  20       IT      HYD
  30       SALES   BLR

  MANAGERS
  MGRNO  MNAME  START_DATE  END_DATE  DEPTNO  REFERENCES DEPT55(DEPTNO) UNIQUE
  1      A      ?	     ?        10
  2	 B	?	     ?        20
  3	 C	?	     ?        30
 
 => in above example one dept is managed by one manager
 and one manager manages exactly one dept so establish
 1:1 relationship between two tables.

   CREATE TABLE DEPT55
    (
      DEPTNO NUMBER(2) PRIMARY KEY,
      DNAME  VARCHAR2(10) UNIQUE NOT NULL,
      CITY   CHAR(3) 
   ); 

   INSERT INTO DEPT55 VALUES(10,'HR','MUM');
   INSERT INTO DEPT55 VALUES(20,'IT','HYD');

   CREATE TABLE MANAGERS
     (
        MGRNO NUMBER(4) PRIMARY KEY,
        MNAME VARCHAR2(10) NOT NULL,
        START_DATE DATE,
        END_DATE  DATE,
        DEPTNO  NUMBER(2)  REFERENCES DEPT55(DEPTNO)
                           UNIQUE
       ); 

   INSERT INTO MANAGERS VALUES(1,'A','10-JAN-21',SYSDATE,10);
   INSERT INTO MANAGERS VALUES(2,'B','10-JAN-21',SYSDATE,10); => ERROR

24-FEB-21 

  DEFAULT :- 
  ----------
 
  => a column can be declared with default value as follows 

            hiredate  date  default sysdate 

  => while inserting if we skip hiredate then oracle 
     inserts default value.

   Example :- 

   CREATE TABLE emp15
    (
        empno      number(4),
        hiredate   date default sysdate
    ); 

  INSERT INTO emp15(empno) VALUES(100);
  INSERT INTO emp15 VALUES(101,'01-JAN-20');
  INSERT INTO emp15 VALUES(102,'');

  SELECT * FROM EMP15 ;
 
  100   02-DEC-20
  101   01-JAN-20
  102   

  Excercise :- 

  ACCOUNTS
  ACCNO  NAME  BAL 

  Rules :- 
 
 1 ACCNO SHOULD NOT BE DUPLICATE AND NULL
 2 NAME SHOULD NOT BE NULL
 3 BAL MUST BE MIN 1000 

 TRANSACTIONS
 TRID   TTYPE   TDATE   TAMT   ACCNO 


 1 TRID should be automatically generated
 2 TTYPE must be 'W' OR 'D' 
 3 TDATE must be automatically inserted as sysdate
 4 TAMT must be multiple of 100
 5 ACCNO should match with ACCOUNTS table ACCNO 

 TABLE LEVEL :- 
 ---------------

 => if we declare constraints after declaring all 
    columns then it is called table level.

 => use table level to declare constraints for 
     multiple columns or combination of columns.

  CREATE TABLE <TABNAME>
   (
    COLNAME DATATYPE(SIZE),
    COLNAME DATATYPE(SIZE),
    ------------------ ,
          CONSTRAINT (col1,col2,---)
  );

 Declaring check constraint at table level :- 
 --------------------------------------------

  MANAGERS
  MGRNO   MNAME   START_DATE  END_DATE 
  100     A       02-DEC-20   01-JAN-20  => INVALID 

     RULE :- END_DATE > START_DATE 

   
 CREATE TABLE MANAGERS
 (
   MGRNO       NUMBER(4),
   MNAME       VARCHAR2(10),
   START_DATE  DATE ,
   END_DATE    DATE,
             CHECK(END_DATE>START_DATE)
  );
 
 INSERT INTO MANAGERS VALUES(100,'A',SYSDATE,'01-JAN-20'); => ERROR
 INSERT INTO MANAGERS VALUES(101,'A','01-JAN-20',SYSDATE);

25-FEB-21 

 composite primary key :- 
 ------------------------

 => if primary key is declared for combination of columns
    then it is called composite primary key.

 => composite primary key is declared at table level.

 => in some tables we need combination of columns to uniquely
    identify records , so combination is declared primary
    key.

  Example :- 

  STUDENT                       COURSE
  SID   SNAME                   CID   CNAME
  1     A                       10    ORACLE
  2     B                       11    JAVA 

  REGISTRATIONS
  SID	CID	DOR	FEE
  1	10	??	??
  1	11	??	??
  2	10	??	??
  
 => in the above example SID,CID combination uniquely identifies
 records in the table so declare this combination as primary key
 at table level.
 
 CREATE TABLE STUDENT
  (
   SID NUMBER(2) PRIMARY KEY,
   SNAME VARCHAR2(10)
  ) ;

 INSERT INTO STUDENT VALUES(1,'A');
 INSERT INTO STUDENT VALUES(2,'B'); 

 CREATE TABLE COURSE
 (
  CID NUMBER(2) PRIMARY KEY,
  CNAME VARCHAR2(10)
 );

 INSERT INTO COURSE VALUES(10,'ORACLE');
 INSERT INTO COURSE VALUES(11,'JAVA ');

 
 CREATE TABLE REGISTRATIONS
  (
    SID  NUMBER(2) REFERENCES STUDENT(SID),
    CID  NUMBER(2) REFERENCES COURSE(CID),
    DOR DATE,
    FEE NUMBER(5),
         PRIMARY KEY(SID,CID)
  );

  INSERT INTO REGISTRATIONS VALUES(1,10,SYSDATE,1000);
  INSERT INTO REGISTRATIONS VALUES(1,11,SYSDATE,1000);
  INSERT INTO REGISTRATIONS VALUES(1,10,SYSDATE,1000); => ERROR
  INSERT INTO REGISTRATIONS VALUES(2,10,SYSDATE,1000);

 Exercise :-

 SALES
 DATEID     PRODID   CUSTID    QTY   AMOUNT
 01-DEC-20  100	     10	       1     5000
 01-DEC-20  100      11        1     5000
 01-DEC-20  101      10        1     2000

 02-DEC-20  100      10        1     5000 


 => identify primary key and create table ? 

 composite foreign key :- 
 -------------------------

 => if combination of columns declared fk then it is called 
 composite foreign key.

 => a composite foreign key refers composite primary key.

 Example :- 

  REGISTRATIONS
  SID	CID	DOR	FEE
  1	10	??	??
  1	11	??	??
  2	10	??	??
 
  CERTIFICATES
  CERTNO    DOI    SID    CID
  1000      ???    1      10
  1001	    ???    1      11
  1002      ???    2      11  => INVALID   
  
   
  => in above example SID,CID combination should match with 
  registrations tables SID,CID combination.so declare this
  combination as fk that refers registrations table pk.

  CREATE TABLE CERTIFICATES
   (
       CERTNO  NUMBER(4) PRIMARY KEY,
       DOI   DATE,
       SID   NUMBER(2),
       CID   NUMBER(2),
           FOREIGN KEY(SID,CID) REFERENCES REGISTRATIONS(SID,CID)
    ); 

 
 which of the following constraint cannot be declared at table level ?

  A UNIQUE
  B CHECK
  C NOT NULL
  D PRIMARY KEY
  E FOREIGN KEY

  ANS :- C 

 Adding constraints to existing table :- 
 ----------------------------------------

 => ALTER command is used to add constraints to existing table.

  CREATE TABLE EMP88
  (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    SAL  NUMBER(7),
    DNO  NUMBER(2)
  );

 Adding primary key :- 

 => add primary key to column empno ?

   ALTER TABLE EMP88
       ADD PRIMARY KEY(EMPNO) ;

 note :- primary key cannot be added to a column that already contains
 duplicates or nulls.

 Adding check constraint :- 

 => add check constraint with condition sal>=3000 ?
 
    ALTER TABLE EMP88 
         ADD CHECK(SAL>=3000);

     ALTER TABLE EMP 
       ADD CHECK(SAL>=3000); => ERROR

 => because some employee salaries are less than 3000 , while 
 adding constraint oracle also validates existing data.if 
 existing data satisfies condition then constraint is added 
 otherwise returns error.

 NOVALIDATE :- 

 => if check constraint is added with NOVALIDATE then oracle will
    not validate existing data , it validates only new data.
    
    ALTER TABLE EMP 
       ADD CHECK(SAL>=3000) NOVALIDATE ;

 Adding foreign key :-

 => add foreign key to column dno that refers dept table pk i.e. deptno ?

   ALTER TABLE EMP88 
      ADD FOREIGN KEY(DNO) REFERENCES DEPT(DEPTNO);

 changing from NULL to NOT NULL :- 

 => modify column ENAME to NOT NULL ?

  ALTER TABLE EMP88
      MODIFY (ENAME NOT NULL);

26-feb-21 

 Droping constraints :- 

 ALTER TABLE <TABNAME>
      DROP CONSTRAINT <NAME> ;

 USER_CONSTRAINTS :- 
 -------------------

 => system table or data dictionary table that stores information
 about constraints declared in table.

  display list of constraints declared in EMP88 table ?

  SELECT constraint_name,constraint_type,
        search_condition 
  FROM user_constraints
  WHERE table_name='EMP88' ; 
 
  SYS_C0010747	 P  
  SYS_C0010751	 R  
  SYS_C0010748	 C   SAL>=3000
  SYS_C0010752	 C   ENAME IS NOT NULL
 
 => drop check constraint in emp88 table ? 

  ALTER TABLE EMP88
    DROP CONSTRAINT SYS_C0010748 ; 

 => drop primary key ?

   ALTER TABLE EMP88
       DROP PRIMARY KEY ;

 => drop primary key in dept table ?

     ALTER TABLE DEPT
       DROP PRIMARY KEY ; => ERROR

     DROP TABLE DEPT;     => ERROR

     TRUNCATE TABLE DEPT; => ERROR


  NOTE :- 
 
     PK constraint cannot be dropped if referenced by some fk
     PK table cannot be dropped if referenced by some fk
     PK table cannot be truncated if referenced by some fk

 WITH CASCADE :- 

1   ALTER TABLE DEPT
      DROP PRIMARY KEY CASCADE ;  

 => drops primary key with dependent foreign keys

 
2   DROP TABLE DEPT CASCADE CONSTRAINTS ; 

 => drops table with dependent foreign keys 

 DELETE rules :- 
 ---------------

  1 on delete no action (default)
  2 on delete cascade
  3 on delete set null 

 => these rules are declared with foreign key.

 => delete rule specifies how child rows are affected if 
    we delete parent row.

 ON DELETE NO ACTION :- 
 ----------------------

 => parent row cannot be deleted if associated with child rows.

 CREATE TABLE DEPT88
  (
   DNO NUMBER(2) PRIMARY KEY,
   DNAME VARCHAR2(10)
  );

  INSERT INTO DEPT88 VALUES(10,'HR');  
  INSERT INTO DEPT88 VALUES(20,'IT');

  CREATE TABLE EMP88
  (
    ENO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    DNO NUMBER(2) REFERENCES DEPT88(DNO)
  );

 INSERT INTO EMP88 VALUES(1,'A',10);


 DELETE FROM DEPT88 WHERE DNO=10; => ERROR (child record found)

 DELETE FROM DEPT88 WHERE DNO=20; => 1 ROW DELETED

 scenario :- 

 ACCOUNTS
 ACCNO   NAME
 100     A
 101     B

 LOANS
 ID  TYPE  AMT  ACCNO  REFERENCES ACCOUNTS(ACCNO) 
 1   H     20   100
 2   C     10   100
 
 RULE :- account closing is not allowed if associated with loans.
 
 ON DELETE CASCADE :- 
 --------------------

 => if parent row is deleted then it is deleted along with child rows.

  CREATE TABLE DEPT88
  (
   DNO NUMBER(2) PRIMARY KEY,
   DNAME VARCHAR2(10)
  );

  INSERT INTO DEPT88 VALUES(10,'HR');  
  INSERT INTO DEPT88 VALUES(20,'IT');

  CREATE TABLE EMP88
  (
    ENO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    DNO NUMBER(2) REFERENCES DEPT88(DNO)
                  ON DELETE CASCADE 
  );

 INSERT INTO EMP88 VALUES(1,'A',10);

 DELETE FROM DEPT88 WHERE DNO=10; => 1 ROW DELETED 

 SELECT * FROM EMP88 ; => NO ROWS 

 scenario :- 

 ACCOUNTS
 ACCNO  NAME  BAL
 100    A     10000
 101    B     20000

 TRANSACTIONS
 TRID  TTYPE  TDATE   TAMT  ACCNO  REFERENCES ACCOUNTS(ACCNO) 
 1      W     26-     2000  100    ON DELETE CASCADE
 2      D     27-     1000  100
 
RULE :- when account is closed along with account delete transactions also

 ON DELETE SET NULL :-
 ----------------------

 => if parent record is deleted then it is deleted without deleting 
    child records but fk will be set to null.

   CREATE TABLE DEPT88
  (
   DNO NUMBER(2) PRIMARY KEY,
   DNAME VARCHAR2(10)
  );

  INSERT INTO DEPT88 VALUES(10,'HR');  
  INSERT INTO DEPT88 VALUES(20,'IT');

  CREATE TABLE EMP88
  (
    ENO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    DNO NUMBER(2) REFERENCES DEPT88(DNO)
                  ON DELETE SET NULL
  );

 INSERT INTO EMP88 VALUES(1,'A',10);

  DELETE FROM DEPT88 WHERE DNO=10; => 1 ROW DELETED

  SELECT * FROM EMP88
 
  ENO  ENAME  DNO
  1    A      NULL 

  scenario :- 

  PROJECTS
  PROJID   NAME  DURATION 
  100	   A	 5
  101      B     3

  EMP
  EMPNO  ENAME  SAL  PROJID 
  1      A      5    100
  2      B      4    101

 RULE :- if project is completed then employee can continue but
 set employee project id to null.

summary :-

 importance of constraints
 types of constraints
 declaring constraints
    column level
    table level 
 adding consraints
 droping constraints
 delete rules
 getting constraints information

 Data Dictionary :- 

 => oracle not only stores data but also stores metadata
    that includes information about users,tables,
    columns and constraints etc.

 => metadata also stored in the form tables and that
 tables are called data dictionary tables or system  
 tables.


 ALL_USERS :- stores information about users 

  SELECT USERNAME FROM ALL_USERS ;

 USER_TABLES :- stores information about tables created by user

  SELECT TABLE_NAME FROM USER_TABLES ; 

  USER_TAB_COLUMNS :- stores information about columns

  SELECT COLUMN_NAME,DATA_TYPE,NULLABLE,
         DATA_LENGTH,DATA_PRECISION,DATA_SCALE
  FROM USER_TAB_COLUMNS
  WHERE TABLE_NAME='EMP' ;

 Database Objects / Schema Objects :- 
 -------------------------------------
  
 1 TABLES
 2 VIEWS
 3 SYNONYMS
 4 SEQUENCES
 5 MATERIALIZED VIEWS
 6 INDEXES 

 VIEWS :- 
 ---------

 => a view is a virtual table because it doesn't store
 data and doesn't occupy memory and it always derives
 data from base table.

 => views are created 

  1 to provide security
  2 to reduce complexity

 => view provides another level of security by granting
 specific rows and columns to users.

 => views are 2 types 

  1 simple views 
  2 complex views 

 Granting permissions to create view :- 
 ------------------------------------

 SYSTEM :- 

  GRANT CREATE VIEW TO BATCH7AM ;

 simple views :- 
 ---------------

 => if view based on single table then it is called simple view

  CREATE VIEW <NAME>
  AS
  SELECT STATEMENT ; 

 Example :- (BATCH7AM)

  CREATE VIEW V1
  AS
  SELECT empno,ename,job,deptno FROM emp ; 

 => oracle creates view "v1" and stores query but not 
 query output.

  SELECT * FROM V1 ; 

 => when above submitted to oracle , it rewrite the query
 as follows.

  SELECT * FROM (SELECT empno,ename,job,deptno FROM emp) ;

 Granting permissions on table to user :- 
 ----------------------------------------

 BATCH7AM :- 
 ------------

 GRANT SELECT,INSERT,UPDATE,DELETE ON V1 TO SCOTT ;

 SCOTT :- 

 1 SELECT * FROM BATCH7AM.V1;

 2 INSERT INTO BATCH7AM.V1 VALUES (555,'ABC','CLERK',20);

 3 UPDATE BATCH7AM.V1 SET JOB='MANAGER' WHERE EMPNO=555;

 4 UPDATE BATCH7AM.V1 SET SAL=4000 WHERE EMPNO=555;

 5 DELETE FROM BATCH7AM.V1 WHERE EMPNO=555;

 row level security :-  
 ----------------------

 BATCH7AM :- 
 -----------

 CREATE VIEW V2
 AS
 SELECT empno,ename,job,deptno 
 FROM emp 
 WHERE deptno=20 ;

 GRANT SELECT,INSERT,UPDATE,DELETE ON V2 TO SCOTT;

 SCOTT :- 

1  SELECT * FROM BATCH7AM.V2

2  INSERT INTO BATCH7AM.V2 VALUES(666,'XYZ','CLERK',30);

=> above insert command is accepted even though it is 
 violating where condition. To overcome this problem
 create view with "WITH CHECK OPTION".

 WITH CHECK OPTION :- 
 ---------------------

 => if view created with "WITH CHECK OPTION" then any DML
  operation through view violates where condition that
  DML is not accepted.

 BATCH7AM :- 
 --------------

 CREATE VIEW V3
 AS
 SELECT empno,ename,job,deptno 
 FROM emp 
 WHERE deptno=20  
 WITH CHECK OPTION ; 

 GRANT SELECT,INSERT,UPDATE,DELETE ON V3 TO SCOTT ;

 SCOTT :- 
 ---------

 INSERT INTO BATCH7AM.V3 VALUES(777,'PQR','MANAGER',30);

 complex views :- 
 -----------------

 => a view said to be complex view

  1 if it is based on multiple tables
  2 if query contains group by 
                      distinct
                      aggregate function
                      expressions
                      set operators
                      subqueries
                   
 Example 1 :- 

 CREATE VIEW CV1
 AS
 SELECT e.empno,e.ename,e.sal,
        d.deptno,d.dname,d.loc
 FROM emp e INNER JOIN dept d
   ON e.deptno = d.deptno ;

 => after creating view whenever we want data from emp & dept
 tables instead of writing join query write the simple 
 query as follows.

  SELECT * FROM CV1 

01-mar-21 :- 

 Example 2 :- 

 CREATE VIEW CV2
 AS
 SELECT d.dname,MIN(e.sal) as minsal,
                MAX(e.sal) as maxsal,
                SUM(e.sal) as sumsal,
                COUNT(*) as cnt
 FROM emp e INNER JOIN dept d
   ON e.deptno = d.deptno 
GROUP BY d.dname ;
 
 => whenever we want dept wise summary then execute the
 following query.

   SELECT * FROM CV2 ; 

    diff b/w simple and complex view ?

          simple                   complex 
 
    1    based on single table     based on multiple tables

    2    query perform simple      query performs complex
         operations                operations like joins
                                   group by etc

    3    allows dmls i.e.          not always allows dmls
         updatable                    
   

   can we create view from another view ?

   ans :- yes 

   CREATE VIEW CV3
   AS
   SELECT  DNAME,CNT
   FROM CV2 ;

   can we create view without base table ?

   ans :- yes , but view cannot be queried.

   CREATE FORCE VIEW V10
   AS
   SELECT * FROM ABC ; 

   
   CREATE VIEW V20
   AS
   SELECT * FROM emp; 

   ALTER TABLE emp 
        ADD(gender char(1));

  => is this new column is added to view or not ?

    ANS :- no , to add this column to view it must be
    recreated , to recreate the view execute the following
    command

   CREATE OR REPLACE VIEW V20
   AS
   SELECT * FROM emp;

  USER_VIEWS :- 
  -------------

  => stores information about views created by user.

  SELECT VIEW_NAME
  FROM USER_VIEWS ; 

 => display query associated with view CV2 ?

  SELECT TEXT
  FROM USER_VIEWS
  WHERE VIEW_NAME='CV2' ;  
    
 Droping view :- 

  DROP VIEW V1 ;

 if we drop table what about views created on table ? 

 ans :- views are not dropped.

 -----------------------------------------------------------

02-mar-21

 synonyms :- 
 -----------

 => a synonym is another name or alternative name for a 
 table or view.

 => synonyms are created when 

   1  tablename is lengthy 
   2  to access tables without owner name

  syn :- CREATE SYNONYM <NAME> FOR <TABNAME>

  Ex :- CREATE SYNONYM E FOR EMP ;

 => after creating synonym instead of using tablename we can use
  synonym name in select,insert,update,delete queries.

  1   SELECT  * FROM  E;
  2   UPDATE E SET SAL=3000 WHERE EMPNO=7844;
  3   DELETE FROM E WHERE EMPNO=7844;

 Accessing tables without owner name :- 
 --------------------------------------

 BATCH7AM :- 

 GRANT ALL ON EMP TO SCOTT ;

 SCOTT :- 

 SELECT * FROM BATCH7AM.EMP;

 CREATE SYNONYM EMP FOR BATCH7AM.EMP;

 SELECT * FROM EMP ;

 Public Synonym :- 
 -----------------

 => public synonyms are created by DBA and granted to users and
 users can access public synonyms without qualifier.

 scenario :- 

  BATCH7AM :- 

  GRANT ALL ON EMP TO SCOTT,HR,SH;

  SCOTT :- 

  CREATE SYNONYM EMP FOR BATCH7AM.EMP;

  HR :- 

  CREATE SYNONYM EMP FOR BATCH7AM.EMP;

 => in the above example every user has to create synonym so there 
 is a complexity to overcome this complexity create public synonym.

 SYSTEM/MANAGER :- 

 CREATE PUBLIC SYNONYM EMP FOR BATCH7AM.EMP;

 GRANT ALL ON EMP TO SCOTT,HR,SH;

 SCOTT :- 

  SELECT * FROM EMP ;

 HR :- 

  SELECT * FROM EMP;

 Question :- 
 ------------

1  CREATE SYNONYM E FOR EMP ;
2  SELECT  * FROM EMP E;
3  RENAME EMP TO E;  => changes tablename from EMP TO E

  diff b/w  synonym and alias ?

        synonym            alias 

   1  permanent            not permanent

   2  stored in db         not stored in db 

   3 scope of the          scope of the alias is upto the query
     synonym is upto
     the schema.

 USER_SYNOYMS :- 

 => stores information about synonyms created by user.

  SELECT SYNONYM_NAME,TABLE_NAME
  FROM USER_SYNONYMS ;

---------------------------------------------------------------------

 Materialized Views :- 
 ---------------------

 => Materialized View is also a db object that stores query output 
    or precomputed result.
 
 => Queries performs complex joins and group by operations on tables
    that contains huge amount of data  takes more time to run. so
    create m.view and store the query output in m.view and whenever 
    we want that output instead of executing query on table execute 
    the query on m.view.

 => M.views are created 

   1 to improve the performance of complex queries.
   2 to maintain local copy for remote database object.
 
 syntax :- 

 CREATE MATERIALIZED VIEW <NAME>
 AS
 SELECT STATEMENT ;

 Example :- 

 CREATE MATERIALIZED VIEW MV1
 AS
 SELECT deptno,SUM(sal) as totsal
 FROM emp
 GROUP BY deptno ;

=> oracle creates M.view MV1 and stores query output, so whenever 
 we want dept wise summary then execute the following query.

  SELECT * FROM MV1 ; 

  10   7450
  20   10875
  30   9450 

 Refreshing M.view :- 
 --------------------

 => if base table data changes by default m.view is not updated 
    and updating  m.view is called refreshing.

 => m.view can be refreshed in 3 ways 

   1 on demand (DEFAULT)
   2 on commit
   3 refresh based on time interval

 on demand :- 
 ------------

 => execute the following procedure to refresh m.view

   EXECUTE DBMS_MVIEW.REFRESH('M.VIEW NAME');

  SQL>UPDATE EMP SET SAL=SAL+1000; 

  SQL>SELECT * FROM MV1;

   10  7450
   20  10875
   30  9450
 
  SQL>EXECUTE DBMS_MVIEW.REFRESH('MV1');

  SQL>SELECT * FROM MV1;

    10   10450
    20   15875
    30   15450

on commit :- 
-------------

 => once changes made to base table are committed then m.view is 
 refreshed automatically.

 SQL>CREATE MATERIALIZED VIEW MV2
     REFRESH ON COMMIT
     AS
     SELECT deptno,SUM(sal) as totsal
     FROM emp
     GROUP BY deptno ;
 
 SQL>SELECT * FROM MV2;

    10   10450
    20   15875
    30   15450

 SQL>UPDATE EMP SET SAL=SAL-1000 ;

 SQL>SELECT * FROM MV2;

    10   10450
    20   15875
    30   15450

 SQL>COMMIT;

 SQL>SELECT * FROM MV2; 

   10   7450
   20   10875
   30   9450

refresh based on time interval :- 
-----------------------------------

=> refreshing m.view based on time intervals like every day,1 hour,
 every month etc.

 CREATE MATERIALIZED VIEW MV3
 REFRESH FORCE
 START WITH SYSDATE NEXT SYSDATE+7
 AS
 SELECT deptno,SUM(sal) as totsal
 FROM emp
 GROUP BY deptno ;

 The following refresh types are available.

COMPLETE : The table segment supporting the materialized view is truncated and repopulated completely using the associated query.
FAST : A fast refresh is attempted. If materialized view logs are not present against the source tables in advance, the creation fails.
FORCE : A fast refresh is attempted. If one is not possible a complete refresh is performed.

creating m.view log :- 
---------------------

CREATE MATERIALIZED VIEW LOG ON scott.emp ;

ENABLE QUERY REWRITE :- 
----------------------

 => if m.view created with "ENABLE QUERY REWRITE" then even if we submit
    query on table oracle uses m.view to execute that query.

 => Adv of " ENABLE QUERY REWRITE " is queries submitted on tables
    also takes adv of m.view.
    
  CREATE MATERIALIZED VIEW MV5
  REFRESH ON COMMIT
  ENABLE QUERY REWRITE 
  AS
  SELECT deptno,SUM(sal)
  FROM emp 
  GROUP BY deptno ;

 => when user submits the following query oracle rewrite the query
  as follows.

   SELECT deptno,SUM(sal)
   FROM emp 
   GROUP BY deptno ;
  
  => SELECT * FROM MV5 ; 

 USER_MVIEWS :- 
 --------------

 => stores information about m.views created by user.

---------------------------------------------------------------------

04-mar-21 

INDEXES :- 

=> index is also a db object created to improve performance of
  data accessing.

=> index in db is similar to index in textbook. In textbook using
 index a particular topic can be located fastly. In db using index
 a particular record can be located fastly.

 => indexes are created on 

  1 columns that are frequently accessed in where clause.
  2 columns that are used in join operation.

 => oracle uses following methods to access data from table.

  1 TABLE SCAN
  2 INDEX SCAN 

 => in TABLE SCAN oracle scans complete table to find the desired record.
 
 => in INDEX SCAN on avg oracle scans half of the table to find the desired record.
    so INDEX SCAN is much faster that table scan.

  Types of Indexes :- 
  --------------------
 
 1 BTREE 
    simple index
    composite index
    unique index
    function based index 
 2 BITMAP 

 simple btree index :- 
 ----------------------

 => if index created on single column then index is called simple
  index.
 
   syn :- CREATE INDEX <NAME> ON <TABNAME>(COLNAME) ; 

   Ex :-  CREATE INDEX I1 ON EMP(SAL) ;

   SELECT * FROM emp WHERE sal=3000;  (INDEX SCAN)
   SELECT * FROM emp WHERE sal>=3000; (INDEX SCAN)
   SELECT * FROM emp WHERE sal<=3000; (INDEX SCAN)
   SELECT * FROM emp WHERE sal<>3000; (TABLE SCAN)

   
 05-mar-21 :- 

 composite index :- 
 ------------------

 => if index created on multiple columns then index is called 
 composite index.

   CREATE INDEX I2 ON EMP(DEPTNO,JOB) ; 

 => oracle uses above index when where condition based on leading
  column of the index i.e. deptno.

 EMP
 DEPTNO	 JOB
 10	 CLERK
 20	 MANAGER
 30	 SALESMAN
 20	 CLERK
 30	 CLERK 
 20	 CLERK
 10	 MANAGER
 30	 SALESMAN

				     20

                       10                          40

             10 CLERK *     20 CLERK *,*    30 CLERK *
             10 MGR *       20 MGR *        30 MGR *
                                            30 SALESMAN *

   SELECT * FROM emp WHERE deptno=20 ; (INDEX SCAN)
   SELECT * FROM emp WHERE deptno=10 and JOB='CLERK' ; (INDEX SCAN)
   SELECT * FROM emp WHERE job='CLERK'; (TABLE SCAN)

 unique index :- 
 --------------

 => unique index doesn't allow duplicates into the column on which
 index is created.
 
    CREATE UNIQUE INDEX I3 ON EMP(ENAME);
 
	                   K

	      G				 Q

  ADAMS *	   JAMES *	MARTIN *        SMITH *
  ALLEN *          JONES *                      SCOTT * 
  BLAKE *
 

  INSERT INTO EMP(EMPNO,ENAME,SAL) VALUES(100,'BLAKE',5000); => ERROR

 => what are the different methods to enforce uniqueness ?

   1 declare primary key / unique constraint
   2 create unique index 

 => oracle implicitly creates a unique index on primary key / unique
    columns and unique index doesn't allow duplicates so primary key
    also doesn't allow duplicates.

 function based index :- 
 -----------------------

 => if index created on function then it is called function based
  index.

       CREATE INDEX I5 ON EMP(ENAME) ;

       SELECT * FROM emp WHERE LOWER(ename)='blake' ;
     
   => for the above query oracle uses table scan because index
      created on ename but where condition based on lower(ename).
      so instead of creating index on ename create index on lower(ename).

       CREATE INDEX I5 ON EMP(LOWER(ENAME));
   
06-mar-21 

  BITMAP indexes :- 
  ------------------

  => a BITMAP index is created on low cardinality columns i.e. 
     columns that contains less distinct values.

     Ex :- gender,job,deptno

  => BITMAP index stores bits 

  BI(JOB)		EMP			BI1(GENDER)
  ANALYST CLERK  MGR    JOB      GENDER		M	F
   0      1      0      CLERK     M             1       0
   0      0      1      MANAGER   F             0       1
   1      0      0      ANALYST   M             1       0
   0      1      0      CLERK     F             0       1
   0      0      1      MANAGER   M             1       0
   1      0      0      ANALYST   M             1       0

 
  CREATE INDEX BI1 ON EMP(GENDER);

  SELECT * FROM EMP WHERE GENDER='M' ;

 => when the above query submitted to oracle it goes index BI1
    and if male bit is set to 1 then corresponding record is 
    selected if bit is set to 0 then row is not selected.

 => bit comparision is much faster than value comparision.

  BTREE VS BITMAP :-

           BTREE                     BITMAP 

   1  recommended on                 recommended on low
      high cardinality               cardinality columns
      columns

   2  stores key values              stores bits 

   3  stores rowids                  doesn't store rowids

   USER_INDEXES :- 
   --------------

   => stores indexes created by user.

   SELECT INDEX_NAME,INDEX_TYPE
   FROM USER_INDEXES
   WHERE TABLE_NAME='EMP';
 
  Droping index :- 
  -----------------

   Drop index i1; 

 => if we drop table what about indexes created on table ? 

    ANS :- indexes are also dropped

 DATABASE
   USERS 
      TABLES
          ROWS & COLS
          CONSTRAINTS
          INDEXES
          TRIGGERS
      VIEWS
      SYNONYMS
      SEQUENCES
      M.VIEWS
      
08-mar-21

 SEQUENCES :- 

 => sequences are created to generate sequence numbers.
 => sequences are created to auto increment column values.
 
 syntax :- 

 CREATE SEQUENCE <NAME>
 [START WITH <VALUE>]
 [INCREMENT BY <VALUE>]
 [MAXVALUE <VALUE>]
 [MINVALUE <VALUE>]
 [CYCLE/NOCYCLE]
 [CACHE <SIZE>]
 
 Ex :- 

  CREATE SEQUENCE S1
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5 ;

 => a sequence has two psuedo columns 

     1 CURRVAL  => returns current value
     2 NEXTVAL  => returns next value

 => S1.NEXTVAL   => generates next value and returns that value


  calling sequence in insert command :-
  --------------------------------------

   CREATE TABLE CUST
   (
     CID  NUMBER(2),
     CNAME VARCHAR2(10)
   );

  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'A');
  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'B');
  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'C');
  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'D'); 
  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'E'); 
  SQL>INSERT INTO CUST VALUES(S1.NEXTVAL,'F'); => ERROR

  SQL>SELECT * FROM CUST ;

   CID   CNAME
   1     A
   2     B
   3     C
   4     D
   5     E

calling sequence in create table command (12c) :- 
---------------------------------------------------

  CREATE TABLE CUST
  (
   CID  NUMBER(2) DEFAULT S1.NEXTVAL,
   CNAME VARCHAR2(10)
  );

   SQL>INSERT INTO CUST(CNAME) VALUES('A'); 

calling sequence in update command :- 
--------------------------------------

 CREATE SEQUENCE S2
 START WITH 100
 INCREMENT BY 1
 MAXVALUE 500; 

 UPDATE  emp SET empno = S2.NEXTVAL ; 
 
 CYCLE/NOCYCLE :- 
 ----------------

 => default is NOCYCLE.

 => if sequence created with NOCYCLE then it starts from start with
    and generates upto MAXVALUE and after reaching MAXVALUE then it 
    stops.

 => if sequence created with CYCLE then it starts from start with
 and generates upto MAXVALUE and after reaching MAXVALUE  then it 
 will be reset to MINVALUE. 

  CREATE SEQUENCE S3
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5
  MINVALUE 1
  CYCLE
  CACHE 4 ; 

   MIN >= START WITH <= MAX  

  SQL>INSERT INTO CUST VALUES(S3.NEXTVAL,'&CNAME');    
    
  SQL>SELECT * FROM CUST ;

      CID    CNAME
      1      A
      2      B
      3      C
      4      D
      5      E
      1      A
      2      B
      3      C
      4      D
      5      E
     
  CACHE 100 :- 

  create sequence s10
  start with 1
  increment by 1
  maxvalue 1000
  minvalue 1
  cycle
  cache 100;
 
 => oracle preallocates 100 values in cache memory and whenever 
 we call s10.nextval oracle goes to cache memory and return
 the value from cache memory. Accessing cache memory is much 
 faster than accessing database , so this improves performance.

  => default cache size is 20 

  => cache size must be less than 1 cycle.

Question :- 

  CREATE SEQUENCE S20
  START WITH 1 
  INCREMENT BY 1
  MAXVALUE 10
  MINVALUE 1 
  CYCLE ; 

 output :- error

 => default cache size is 20 but cache size must be less than one cycle

USER_SEQUENCES :- 
-----------------

=> stores information about sequences created by user.

    CREATE SEQUENCE S10;

  SELECT MIN_VALUE,MAX_VALUE,INCREMENT_BY,CYCLE_FLAG
  FROM USER_SEQUENCES
  WHERE SEQUENCE_NAME='S10' ;

altering sequence :-
-------------------

 ALTER SEQUENCE S10 MAXVALUE 10; 

 ALTER SEQUENCE S10 CYCLE ;  => ERROR

 ALTER SEQUENCE S10 CACHE 5;

 ALTER SEQUENCE S10 CYCLE ; 

Question :- 

  create sequence s10
  start with 1
  increment by 1
  maxvalue 1000 ;

 => after reaching 50, how to reset the sequence ? 

  alter sequence s10 increment by -49 ; 
  select s10.nextval from dual ; => 1
  alter sequence s10 increment by 1;

  Droping Sequence :-
  -------------------

   drop sequence s10 ;

 identity(12C)  :- 

 => used to generate sequence numbers.
 => used to auto increment column values.

   CREATE TABLE cust
    (
      cid number(2) generated always as identity,
      cname varchar(10)
    );

   INSERT INTO cust(cname) VALUES('&cname');

   
   SELECT * FROM CUST ;
 
   CID    CNAME
   1      A
   2      B
   3      C
   4      D
   5      E


-------------------------------------------------------------------------

10-mar-21

	 		 PL/SQL 

 
   			   ORACLE

                    SQL               PL/SQL

             (non-procedural)        (procedural)        


  Features :- 

  1 improves performance :- 
  
   => in pl/sql , sql commands can be grouped into one block and
   we submit that block to oracle and oracle executes that block and
   gives response to user. so in pl/sql no of req & res between user
   and oracle are reduced and performance is improved.

  2 supports conditional statements like if-then-else.

  3 supports loops like while,for 

  4 supports error handling :- 

  => in pl/sql , if any statement causes error then we can handle
     that error and we can replace system generated message with
     our own user friendly message.

  5  supports modular programming :- 
     ------------------------------

     => in pl/sql a big program can be divided into small modules 
        called procedures and functions.

  6  supports reusability :- 
     ------------------------

   => pl/sql programs can be centralized i.e. can be stored in db.
      so applications which are connected to db can reuse that
      programs.

  7 supports security :- 
    ------------------

   => pl/sql programs are stored in db, so they are secured only
  authorized users can execute these programs.

 => pl/sql programs are 2 types 

 1 Anonymous blocks
 2 Named blocks 
       procedures
       functions
       packages
       triggers 

 Anonymous Block :- 

 => a pl/sql program without name is called anonymous block.
 
  DECLARE 
    <declaration-part>;   (optional)
  BEGIN
    <execution-part>;     
  END;
   /   => starts program compilation and execution

 how to print messages :- 
 ------------------------

  DBMS_OUTPUT.PUT_LINE(message);
  ----------- ---------
    PACKAGE    PROCEDURE

  => by default messages are not send to output , to send messages     
     to output execute SET SERVEROUTPUT ON command.

  SQL>SET SERVEROUTPUT ON

  SQL>BEGIN
         DBMS_OUTPUT.PUT_LINE('welcome');
      END;
       /
   welcome

   how to write pl/sql program :- 
   --------------------------------

   1 EDITORS
   2 IDEs (integrated development environment)

 
	           Editors                     IDEs

   coding   	    yes			       yes

   compile          no                         yes

   execute          no                         yes 

   debug            no                         yes

   ex              notepad                     sql developer,TOAD
    
11-MAR-21

 using Notepad :- 
 ---------------

 => open notepad and enter following code 

   begin
     dbms_output.put_line('welcome');
   end;
    /

 => save the program as e:\vijay\"prog1.sql"

 => go to sqlplus and compile & run the program as follows 

     SQL>@E:\VIJAY\PROG1.SQL

 Datatypes in PL/SQL :-

 1 Number(p) / Number(p,s)
 2 char/varchar2/clob
 3 nchar/nvarchar2
 4 date / timestamp
 5 bfile/blob
 6 binary_float / binary_double
 7 binary_integer / pls_integer
 8 boolean
 
 1-6  => allowed in sql,pl/sql 
 7-8  => allowed only in pl/sql but not allowed in sql

 Declaring Variable :- 
 --------------------

  variablename  datatype(size) ;

  x  number(4);
  s  varchar2(10);
  d  date;

Assigning value to variable :-
--------------------------------

   variablename :=  value ;                :=  assignment operator
                                            =  comparision
   x := 100;
   s := 'abc';
   d := sysdate;

=> write a prog to add two numbers ? 

  DECLARE
    a  Number(3);
    b  Number(3);
    c  Number(4);
  BEGIN 
    a := 100;
    b := 200;
    c := a+b;
    dbms_output.put_line(c);
  END;
   /

 How to input values at runtime :- 
 ----------------------------------

 => to input values at runtime use variables prefixed with "&".

              a := &a;

 =>  enter value for a :- 50

              a := 50; 

  DECLARE
    a  Number(3);
    b  Number(3);
    c  Number(4);
  BEGIN 
    a := &a;
    b := &b;
    c := a+b;
    dbms_output.put_line(c);
  END;
   /
    
 Write a prog to input date and print day of the week ? 
 
 DECLARE
   d   date;
 BEGIN
   d := '&date';
   dbms_output.put_line(TO_CHAR(d,'day'));
 END;
  /
 
 DB programming with PL/SQL :- 
 -----------------------------

 => to perform operations over db , execute SQL commands from pl/sql
    program and the following commands are executed from pl/sql
    program.

 1 DML (insert,update,delete,insert all,merge)
 2 DQL (select)
 3 TCL (commit,rollback,savepoint)

12-mar-21

 SELECT statement syntax  :- 
 ---------------------------
 
 SELECT columns INTO variables
 FROM tabname
 WHERE condition;

 Ex :- 

1  SELECT ename INTO x
   FROM emp 
   WHERE empno=7369;

 2 SELECT ename,sal INTO x,y
   FROM emp
   WHERE empno=7369;

  write a prog to input empno and print name & salary ? 

  DECLARE
      v_eno   Number(4);  
      v_name  varchar2(10);
      v_sal   Number(7,2);
  BEGIN
      v_eno := &empid;
      SELECT ename,sal INTO v_name,v_sal
      FROM emp 
      WHERE empid=v_eno;
      dbms_output.put_line(v_name||' '||v_sal);
  END;
   /
 
 Write a prog to input empno and display experience of the employee ?

 DECLARE
   v_eno   NUMBER(4);
   v_hire  DATE;
   v_expr  NUMBER(2);
 BEGIN
    v_eno := &empno;
    SELECT hiredate INTO v_hire
    FROM emp 
    WHERE empno = v_eno;
    v_expr := (SYSDATE-v_hire)/365;
    dbms_output.put_line('Experience = ' ||v_expr||' years');
 END;
  /

 conditional statements :- 
 -------------------------

 1 if-then-else
 2 multi if
 3 nested if

1 if-then-else :- 

  if cond
    statements;
  else
    statements;
  end if;

2 multi if :- 
 
   if cond1
     statements;
   elsif cond2
     statements;
   elsif cond3
     statements;
   else
     statements;
   end if;

3 nested if :- 

   if cond
     if cond
       statements;
     else
       statements;
     end if;
  else
    statements;
  end if;

 
 write a prog to input empno and increment employee sal by specific
 amount , after increment if sal exceeds 5000 then cancel that
 increment ? 

 DECLARE
   v_eno  Number(4);
   v_amt  Number(4);
   v_sal  Number(7,2);
 BEGIN
   v_eno := &empno;
   v_amt := &amount;   
   UPDATE emp SET sal=sal+v_amt WHERE empno=v_eno;
   SELECT sal INTO v_sal FROM emp WHERE empno=v_eno;
   IF v_sal>5000  THEN
     ROLLBACK;
   ELSE
     COMMIT;
   END IF;
 END;
 /

Write a prog to input empno and calculate experience of the employee 
if experience > 40 then delete the record from table ?

 DECLARE
   v_eno   NUMBER(4);
   v_hire  DATE;
   v_expr  NUMBER(2);
 BEGIN
    v_eno := &empno;
    SELECT hiredate INTO v_hire
    FROM emp  
    WHERE empid = v_eno;
    v_expr := (SYSDATE-v_hire)/365;
    IF v_expr > 40 THEN
      DELETE FROM emp WHERE empid=v_eno;
    END IF;
 END;
  /
  
 write a prog to input empno and increment employee sal as follows 

   if deptno=10 incr sal by 10%
             20             15%
             30             20%
            others          5%

 
  DECLARE
    v_eno   Number(4);
    v_dno   Number(2);
    v_pct   Number(3);
  BEGIN
    v_eno := &empid;
    SELECT deptno INTO v_dno FROM emp11 WHERE empid=v_eno;
    IF v_dno=10 THEN
       v_pct := 10;
    ELSIF v_dno=20 THEN
       v_pct := 15;
    ELSIF v_dno=30 THEN
       v_pct := 20;
    ELSE
       v_pct := 5;
    END IF;
    UPDATE emp11 SET sal=sal+(sal*v_pct/100) WHERE empid=v_eno;
    COMMIT;
 END;
  /

13-mar-21 :- 

ACCOUNTS
ACCNO   NAME   BAL
100	A      10000
101	B      20000

=> write a prog to process bank transaction (w/d) ? 

   DECLARE
    v_acno  Number(4);
    v_type  char(1);
    v_amt   Number(7,2);
    v_bal   Number(7,2);
   BEGIN
      v_acno := &accno;
      v_type := '&type'; 
      v_amt  := &amount;
      IF v_type='w' THEN
         SELECT bal INTO v_bal FROM accounts WHERE accno=v_acno;
         IF v_amt > v_bal THEN
            dbms_output.put_line('insufficient balance');
         ELSE
            UPDATE accounts SET bal=bal-v_amt WHERE accno=v_acno;
         END IF;
      ELSIF v_type='d' THEN
         UPDATE accounts SET bal=bal+v_amt WHERE accno=v_acno;
      ELSE
         dbms_output.put_line('invalid transaction type');
      END IF;
      COMMIT;
  END;
   /

 Reference Types :- 
 ------------------

 1 %type
 2 %rowtype

 %TYPE :- 

 => used to refer datatype of a column in a table.

    ex :-  v_ename  emp.ename%type;

 => whatever datatype & size declared for ename column the same 
    type and size assigned to variable v_ename.

 => Adv of %type is it reduces complexity.

 %ROWTYPE :- 
 -----------

 => used to refer table row type.

    ex :-   e   emp%rowtype;

 => a row from emp table can be assigned to variable "e".

       SELECT * INTO e
       FROM emp 
       WHERE empno=7369;   

    e
    empno ename job   mgr  hiredate   sal comm  deptno 
    7369  SMITH clerk      17-DEC-80  800 NULL  20

  => from the rowtype variable individual field values are accessed by
     using rowtypevar.fieldname.

          e.sal    => 800
          e.job    => clerk
          e.deptno => 20

15-mar-21 :- 

 => write a prog to input empno and print employee details ? 

   DECLARE
     v_eno    EMP.EMPNO%TYPE;
     v_emp    EMP%ROWTYPE;
   BEGIN
     v_eno := &empno;
     SELECT * INTO v_emp FROM emp WHERE empno=v_eno;
     dbms_output.put_line(v_emp.ename||' '||
                          v_emp.sal||' '|| 
                          v_emp.job);
   END;
    /

  => write a prog to calculate a particular student total,avg,result
     and insert into result table ? 

  STUDENT
  SNO  SNAME  S1  S2  S3
  1    A      80  90  70
  2    B      30  60  50

  RESULT
  SNO  STOT  SAVG  SRES 


  DECLARE
    v_sno   STUDENT.SNO%TYPE;
    v_stud  STUDENT%ROWTYPE;
    v_res   RESULT%ROWTYPE; 
  BEGIN
     v_sno := &sno;
     SELECT * INTO v_stud FROM student WHERE sno=v_sno;
     v_res.stot := v_stud.s1 + v_stud.s2 + v_stud.s3;
     v_res.savg := v_res.stot/3;
     IF v_stud.s1>=35 AND v_stud.s2>=35 AND v_stud.s3>=35 THEN
        v_res.sres := 'pass';
     ELSE
        v_res.sres := 'fail';
     END IF;     
     INSERT INTO RESULT VALUES(v_stud.sno,v_res.stot,v_res.savg,v_res.sres);
     COMMIT;
  END;
  /

           
 v_stud
 SNO  SNAME  S1  S2  S3
 1    A      80  90  70

 v_res
 SNO  STOT  SAVG  SRES 
      240   80    

 Loops :- 
 ---------

 =>  loops are used to execute statement repeatedly multiple times.
 => PL/SQL supports 3 types of loops 

 1 simple loop
 2 while loop
 3 for loop 

1 simple loop :- 

  LOOP
    statements;
    exit when <cond>;
  END LOOP;

 if cond=false loop continues
 if cond=true  loop terminates 

 2 while loop :- 

    WHILE(cond)
   LOOP
      statements;
   END LOOP;

  => if cond=true loop continues
  => if cond=false loop terminates 

 3 for loop :- 

   FOR <var> IN <low val>..<upp val>
  LOOP
    statements;
  END LOOP;

  FOR x IN 1..10
 LOOP
   statements; 
 END LOOP;

 1 variable "x" is declared implicitly as number type
 2 by default value of "x" is incremented by 1
 3 scope of the "x" is upto the for loop
 4 "x" is readonly variable.

 REVERSE FOR LOOP :- 

  FOR x IN REVERSE 1..10
 LOOP
    statements;
 END LOOP;

 => Write a prog to print nos from 1 to 20 ? 

using simple loop :-

  DECLARE
    x  NUMBER(2) := 1;
  BEGIN
    LOOP
      dbms_output.put_line(x);
      x := x+1;
      exit when x>20;
    END LOOP;
 END;
   / 
  
using while loop :-
----------------

  DECLARE
    x  NUMBER(2) := 1;
  BEGIN
    WHILE(x<=20)
   LOOP
      dbms_output.put_line(x);
      x := x+1;
   END LOOP;
  END;
   /
   
using for loop :- 
------------------

 BEGIN
   FOR x IN 1..20 
 LOOP
   dbms_output.put_line(x);
 END LOOP;
 END;
  /

 BEGIN
   FOR x IN REVERSE 1..20 
 LOOP
   dbms_output.put_line(x);
 END LOOP;
 END;
  / 

 16-mar-21 :- 
 ------------

 => write a prog to print 2021 calendar ? 

         date         day 
         01-jan-21    ?
 
         31-dec-21    ? 

    DECLARE
      d1  date;
      d2  date;
    BEGIN
      d1 := TO_DATE('01-JAN-21');
      d2 := TO_DATE('31-DEC-21');
      WHILE(d1<=d2)
     LOOP
       dbms_output.put_line(d1||'    '||TO_CHAR(d1,'day'));
       d1 := d1+1;
     END LOOP;
     END;
       /

 => write a prog to print sundays between two given dates ? 

    DECLARE
      d1  date;
      d2  date;
    BEGIN
      d1 := TO_DATE('01-JAN-21');
      d2 := TO_DATE('31-DEC-21');
      WHILE(d1<=d2)
     LOOP
       IF TO_CHAR(d1,'dy')='sun' THEN
          dbms_output.put_line(d1||'    '||TO_CHAR(d1,'day'));
       END IF;
       d1 := d1+1;
     END LOOP;
     END;
       /

 CURSORS :- 
 -----------

 => CURSOR are used to process row-by-row in PL/SQL program.

 => from pl/sql prog if we submit a select statement to oracle,
    it goes to db and gets the data and copies that data into
    temporary memory called program global area (PGA), using cursor
    we can give name to that memory and access row-by-row into
    the pl/sql program and process the row.

 => follow below steps to use cursor in pl/sql program.

  1 DECLARE
  2 OPEN
  3 FETCH
  4 CLOSE

 Declaring cursor :- 
 --------------------
 
  CURSOR <NAME> IS SELECT STATEMENT ;

  Ex :-  CURSOR C1 IS SELECT * FROM emp;  

 Opening cursor :- 
 -----------------

       OPEN <cursor-name> ;
       OPEN c1;
 
  1 select statement submitted to oracle.
  2 data returned by select statement is copied to temporary storage.
  3 cursor c1 points to the temporary storage.

 Fetching records from cursor :- 
 ------------------------------

=> FETCH statement is used to fetch record from cursor.

     syn :-  FETCH <cursor-name> INTO <variables>;
     Ex :-   FETCH C1 INTO x,y,z--;

 => a fetch statement fetches one row at a time , but to process multiple
  rows fetch statement should be executed multiple times. To execute
  fetch statement multiple times keep the fetch statement inside a 
  loop.

Closing cursor :- 
------------------

    close <cursor-name>;
    close c1;

cursor attributes :-
-----------------------

 1 %FOUND :- 
 -----------

   TRUE   =>  if fetch successful
   FALSE  =>  if fetch unsuccessful

 2 %NOTFOUND :- 
   -------------
  
   TRUE  => if fetch unsuccessful
   FALSE => if fetch successful 

 3  %ROWCOUNT :- 
    ------------

    => returns no of rows fetched successfully

 4  %ISOPEN :- 
    -----------

    TRUE   => if cursor is open
    FALSE  => if cursor is not open

 C1%FOUND
 C1%NOTFOUND
 C1%ROWCOUNT
 C1%ISOPEN

 17-mar-21 :- 
 -------------

 => write a prog to print all employee names and salaries ? 

   DECLARE
      cursor c1 is select ename,sal from emp ;
      v_ename  emp.ename%type;
      v_sal    emp.sal%type;
   BEGIN
      open c1;
   LOOP
      fetch c1 into v_ename,v_sal;
      exit when c1%notfound;
      dbms_output.put_line(v_ename||'  '||v_sal);
   END LOOP;
      close c1;
   END;
    /

  FOR LOOP CURSOR :- 

  FOR <var> IN <cursor-name>
 LOOP
    statements;
 END LOOP;

 FOR r IN C1
LOOP
  statements;
END LOOP;

  => Adv of FOR LOOP CURSOR is opening the cursor,fetching records
 from cursor and closing cursor is not required and all these
 operations are done implicitly.

=> every time for loop executes a record is fetched from cursor and
  assigned to loop variable "r" and variable "r" is also declared
  implicitly as rowtype.

 DECLARE
    cursor c1 is select ename,sal from emp;
 BEGIN
    FOR r IN c1
 LOOP
   dbms_output.put_line(r.ename||'   '||r.sal);
 END LOOP;
 END;
  /

 => write a prog to print total salary ? 

   DECLARE
    cursor c1 is select sal from emp ;
    v_totsal  number(7) := 0;
   BEGIN
    FOR r IN c1
   LOOP
      v_totsal := v_totsal + r.sal;
  END LOOP;
     dbms_output.put_line('Total Salary ='||v_totsal);
   END;
    /
 
 => write  a prog to print maximum salary ?

 => write a prog to print minimum salary ? 
     
 => write a prog to print employee names as follows ?

    smith,allen,ward,jones,martin,blake,------
9
    DECLARE
      cursor c1 is select ename from emp ;
      s  varchar2(500);
    BEGIN
      FOR r in c1
    LOOP
      s :=  s||r.ename||',';
    END LOOP;
     dbms_output.put_line(s);
    END;
     /

 LISTAGG :- 

 => a built-in function introduced in 11g.
 => function used to aggregate or concatenate column values seperated
    by some delimiter.

    LISTAGG(colname,seperator) WITHIN GROUP (ORDER BY col ASC/DESC)

 SELECT LISTAGG(ename,',') WITHIN GROUP (ORDER BY empno ASC) 
 FROM emp ;

 => display dept wise employee names ?

  SELECT deptno,
    LISTAGG(ename,',') WITHIN GROUP (ORDER BY ename ASC) AS NAMES
  FROM emp
  GROUP BY deptno  
  ORDER BY 1 ASC ; 

 18-mar-21 :- 
 -------------

 raise_salary
 empno   pct
 7369    15
 7499    20
 7521    10
 7566    20
 7654    12

 write a prog to increment employee salaries based on the pct in
 raise_salary table ? 

 DECLARE
   cursor c1 is select empno,pct from raise_salary;
 BEGIN
  for r in c1
 loop
   update emp set sal=sal+(sal*r.pct/100) where empno=r.empno;
 end loop;
 END;
 /

=> write a prog to calculate all the students total,avg,result and
   insert into result table ?

STUDENT
SNO  SNAME  S1  S2  S3
 1   A      80  90  70
 2   B      30  60  50

RESULT
SNO   STOT  SAVG  SRES 

DECLARE
  cursor c1 is select sno,s1,s2,s3 from student;
  r  result%rowtype;
BEGIN
  for s in c1
 loop
   r.stot := s.s1+s.s2+s.s3;
   r.savg := r.stot/3;
   if s.s1>=35 and s.s2>=35 and s.s3>=35 then
       r.sres := 'pass';
   else
       r.sres := 'fail';
   end if;
   insert into result values(s.sno,r.stot,r.savg,r.sres);
 end loop;
END;
 /

=>  write a prog to copy data from custs to custt ?

 CUSTS
 CID   CNAME 	  		DOB
 1    sachin tendulkar		???
 2    rohit sharma              ???

 CUSTT
 CID	FNAME	LNAME	 AGE

REF CURSOR :- 
-------------

 => a cursor acts like a constant because select statement assigned
   to cursor cannot be changed during program execution but REF CURSOR
   acts like a variable because select statemnt assigned to cursor
   can be changed during program execution.

 => a cursor is called static but ref cursor is called dynamic

 Declaring REF CURSOR :- 
 ----------------------

        C1   SYS_REFCURSOR;

 Assigning data to cursor :- 
 ---------------------------

        OPEN C1 FOR SELECT * FROM emp;

 Example :- 

  DECLARE 
     c1   SYS_REFCURSOR;
     e    emp%rowtype;
     d    dept%rowtype;
  BEGIN 
     open c1 for select * from emp ;
 loop
    fetch c1 into e;
    exit when c1%notfound;
    dbms_output.put_line(e.ename||' '||e.sal);
 end loop;
    close c1;
    open c1 for select * from dept;
 loop
    fetch c1 into d;
    exit when c1%notfound;
    dbms_output.put_line(d.deptno||' '||d.dname);
 end loop;
    close c1;
END;
 /

 difference b/w cursor and ref cursor ?

         cursor                     ref cursor
 
 1   acts like a constant          acts like a variable

 2   select stmt cannot be         select stmt can changed
     changed during program        during program execution
     execution

 3   static                         dynamic

 4   select stmt assigned           select stmt assigned at the time
     at the time of                 of opening
     declaration

 5   not declared with               declared with datatype
     datatype

 6   cannot be used as               can be used as procedure 
     procedure parameter             parameter

------------------------------------------------------------------

19-mar-21 

 Exception Handling / Error Handling :- 
 --------------------------------------

 1 syntax errors
 2 logical errors
 3 runtime errors (Exceptions)

 => errors that are raised during program execution are called
 runtime errors.

     a   number(3);
  
     a := &a; => 10000 => runtime error

 => in pl/sql , if any statement causes runtime error then program
 execution is terminated and oracle displays message , to continue
 program execution and to replace system generated message with our
 own message we need to handle that runtime error.

 => to handle runtime errors include a block called exception block.

  DECLARE
    <declaration-part>;
  BEGIN
    <execution-part>;   => statements causes exception
  EXCEPTION
    <error handling>;   => statements handles exception
  END;
   /

 => if any statement causes exception then control is transferred
 to exception block and executes the statements in exception block.

 => exceptions are 2 types 

 1 system defined
 2 user defined 

 1 system defined :- 
 -------------------

 => error raised by oracle are called system defined errors 

 1 ZERO_DIVIDE :- 
 ----------------

  => raised when we try to divide a number with 0

     a := &a;  10
     b := &b;  0
     c := a/b; => ZERO_DIVIDE error

 2 VALUE_ERROR :- 
   -------------

  => raised when variable size or type mismatches.

       1   a   number(3);
     
           a := &a; => 10000 => VALUE_ERROR

       2   a   number(3);

           a := 'abc';  => VALUE_ERROR

3  INVALID_NUMBER :- 
   -------------------

  => raised when we perform invalid arithmetic calculation.

       d  date;

       d := '01-JAN-21' + 50 ; => INVALID_NUMBER

 4 NO_DATA_FOUND :- 
   ---------------

  => raised when data not found in the table.

       veno := &empno; => 9999

    SELECT sal INTO v_sal FROM emp WHERE empno=veno; => NO_DATA_FOUND


 5 TOO_MANY_ROWS :- 
   ---------------

  => raised when select statement returns more than one row

      vdno := &deptno; => 20 

     SELECT ename INTO vename FROM emp WHERE deptno=vdno; => TOO_MANY_ROWS

 6 DUP_VAL_ON_INDEX :- 
   --------------------

   => raised when we try to insert duplicate values into primary key
     column.

    create table a(a number(2) primary key);
    insert into a values(10);
    insert into a values(10);  => DUP_VAL_ON_INDEX

 Example 1 :- 

  DECLARE  
    a   number(3);
    b   number(3);
    c   number(3); 
 BEGIN
    a := &a;
    b := &b;
    c := a/b;
    dbms_output.put_line(c);	
 EXCEPTION
    when zero_divide then
       dbms_output.put_line('divisor cannot be zero');
    when value_error then
       dbms_output.put_line('value exceeding size');
 END;
  /

 input :- 

  a = 10
  b = 0
 
 output :- divisor cannot be zero

 input :- 

  a = 10
  b =  222222
 
 output :- value exceeding size

20-mar-21 

Example 2 :- 

write a prog to input empno and print name & sal ?

 DECLARE
   v_eno    emp.empid%type;
   v_name   emp.ename%type; 
   v_sal    emp.sal%type;
 BEGIN
    v_eno := &empno;
    SELECT ename,sal INTO v_name,v_sal 
    FROM emp 
    WHERE empid = v_eno;
    dbms_output.put_line(v_name||' '||v_sal);
 EXCEPTION
    when no_data_found then
        dbms_output.put_line('employee does not exists');
    when value_error then
        dbms_output.put_line('value exceeding size');
 END;
   /

 user defined exceptions :- 
 -------------------------

 => exceptions declared and raised by user are called user defined exception.
 => user defined exceptions must be raised by user by using

	  1 raise statement
  	  2 raise_application_error

 using raise statement :- 
 -------------------------

       raise  <exception-name>;

       raise abc;

 => exception "abc" must be declared in declaration part as follows

         abc  exception;

  DECLARE  
    a   number(3);
    b   number(3);
    c   number(3); 
    abc  exception;
 BEGIN
    a := &a;
    b := &b;
    if b=1 then
       raise abc;
    end if;
    c := a/b;
    dbms_output.put_line(c);	
 EXCEPTION
    when zero_divide then
       dbms_output.put_line('divisor cannot be zero');
    when value_error then
       dbms_output.put_line('value exceeding size');
    when abc then
       dbms_output.put_line('divisor cannot be one');
 END;
  /
   
using RAISE_APPLICATION_ERROR :- 
--------------------------------

  RAISE_APPLICATION_ERROR(error code,error msg);

  error code  => -20001 to -20999
  error msg   => any text 

Example :- 

 write a prog to input empno and increment employee salary and
 sunday updates are not allowed ? 

 DECLARE
  v_eno emp.empid%type;
  v_amt number(4);
 BEGIN
   v_eno := &empid;
   v_amt := &amount;
   if TO_CHAR(sysdate,'dy')='sun' then
      RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
   end if;
   UPDATE emp SET sal=sal+v_amt WHERE empid=v_eno;
   COMMIT;
 END;
  /

 diff b/w raise & raise_application_error ?

 1 use raise statement to raise exception and to handle exception
 2 use raise_application_error to raise exception but do not want to handle 
 3 in raise statement exception is raised by using name.
 4 in raise_application_error exception raised by using code.

22-mar-21 

PRAGMA EXCEPTION_INIT :- 

=> using this we can associate user define exception with oracle
 predefine error.

=> using this we can give name to the error that is not having 
   predefine name.

    PRAGMA EXCEPTION_INIT(exception-name,error code);

    abc exception;
    PRAGMA EXCEPTION_INIT(abc,-2292);

 => in PL/SQL program if we want to handle -2292 error use name "abc".

 Example :- 

  CREATE TABLE emp44
   (
    empno  number(4) primary key,
    ename  varchar2(10) not null,
    sal    number(7,2) check(sal>=3000)
   );

  => write a prog to insert data into emp44 table ? 

   DECLARE
     v_eno  emp44.empno%type;
     v_name emp44.ename%type; 
     v_sal  emp44.sal%type;
     abc exception;
     PRAGMA EXCEPTION_INIT(check_violated,-2290);
  BEGIN
     v_eno  := &empno;
     v_name := '&name';
     v_sal  := &sal;
     INSERT INTO emp44 VALUES(v_eno,v_name,v_sal);
     COMMIT;
  EXCEPTION
     when dup_val_on_index then
        dbms_output.put_line('empno should not be duplicate');
     when abc then
        dbms_output.put_line('sal >= 3000');
  END;
    /

---------------------------------------------------------------------

Named PL/SQL blocks :- 
----------------------

 1 procedures
 2 functions 
 3 packages
 4 triggers 

sub-programs :- 

1 procedures
2 functions 

Advantages :- 
-------------

1 modular programming :- 
  -----------------------

 => in pl/sql with the help of procedures & functions a big program 
    can be divided into small modules.

2 reusability :- 
  --------------

 => procedures & functions can be centralized i.e. can be stored in
    db.so applications which are connected to db can reuse 
    procedures & functions.

3 security :- 
  ------------

 => proc & func are stored in db , so they are secured only authorized
    users can execute these programs.

4 invoked from front-end applications :- 
  --------------------------------------

 => proc & func can be invoked from front-end applications like
  java,.net 

5 improves performance :- 
  -----------------------

 => proc & func improves performance because they are precompiled
    i.e. compiled already and ready for execution. when we create
    procedure program is compiled and stored in db and when we 
    call procedure only execution is repeated but not compilation.
    so this improves performance.

 procedures :- 
 --------------

 => a procedure is a named pl/sql block that accepts some input
 performs some action on db and may or may not returns a value.

=> procedures are created to perform one or more dml operations on db

=> procedures are 2 types 

  1 stored or standalone procedures
  2 packaged procedures 
 
standalone or stored procedures :- 
----------------------------------

 => these procedures are stored as seperate object in database .
 => these procedures are directly created under the schema.

   CREATE OR REPLACE PROCEDURE <NAME>(parameters if any)
   IS
     <declaration-part>;
   BEGIN
     statements;
   END;
    /

 parameters :- 
 -------------

=> we can declare parameters and we can pass values to parameters
=> parameters are 3 types 

 1 IN
 2 OUT
 3 IN OUT

 IN parameters :- 
 ----------------

 => always recieves value from calling program
 => default
 => read only 

OUT parameter :- 
------------------

=> always sends value to calling program.
=> write only

IN OUT parameter :-
-------------------

=> always recieves and sends 
=> read & write 

       PARAMETERNAME   TYPE    DATATYPE

Example 1 :- 

 create procedure to increment specific employee sal by specific
 amount ? 
 
 CREATE OR REPLACE 
    PROCEDURE update_salary(p_eno IN emp11.empid%type,p_amt IN number)
 IS
 BEGIN
   UPDATE emp11 SET sal=sal+p_amt WHERE empid=p_eno;
   COMMIT;
 END;
  /

 procedure created ( compiled + stored in db) 

 Execution :- 
 ------------

 1 sql prompt
 2 another pl/sql block
 3 front-end applications 

 executing from sqlprompt :- 
 ---------------------------

  EXECUTE procname(parameters); 

 SQL>EXECUTE update_salary(7369,1000);

 Executing from another pl/sql program :- 
 ---------------------------------------

 1 positional notation
 2 named notation 

 positional notation :- 
 ----------------------

 => parameters are mapped through positions.

 DECLARE
   v_eno   emp.empno%type;
   v_amt   number(4);
 BEGIN
   v_eno := &empno;
   v_amt := &amount;
   UPDATE_SALARY(v_eno,v_amt);
 END;
  /

 named notation :- 
 -----------------

 => in named notation parameters are mapped through names.

  DECLARE
   v_eno   emp.empid%type;
   v_amt   number(4);
 BEGIN
   v_eno := &empid;
   v_amt := &amount;
   UPDATE_SALARY(p_eno=>v_eno,p_amt=>v_amt);
 END;
  /

 NOTE :- named notation is convenient than positional notation   
 because in named notation we can pass values to parameters 
 in any order.

OUT parameter example :- 
------------------------

=> create procedure to increment specific employee sal by specific
 amount after increment send the updated sal to calling program ?

 CREATE OR REPLACE PROCEDURE update_salary
 (
   p_eno IN emp.empid%type,
   p_amt IN NUMBER,
   p_sal OUT emp.sal%type
 )
 IS
 BEGIN
    UPDATE emp SET sal=sal+p_amt WHERE empid=p_eno;
    COMMIT;
    SELECT sal INTO p_sal FROM emp WHERE empid=p_eno;
 END;
  /

25-mar-21 

Example 3 :- 

CREATE TABLE emp33
 (
   empno number(4) primary key,
   ename varchar2(10) not null,
   sal   number(7,2) check(sal>=3000)
 );

 create procedure to insert record into emp33 table ? 

 CREATE OR REPLACE PROCEDURE insert_record
 (
   p_eno IN emp33.empno%type,
   p_name IN emp33.ename%type,
   p_sal  IN emp33.sal%type,
   p_msg  OUT varchar2
 )
 IS
 BEGIN
   INSERT INTO emp33 VALUES(p_eno,p_name,p_sal);
   COMMIT;
   p_msg := 'record inserted successfully';
 EXCEPTION
   when others then
       p_msg := SQLERRM;      
 END;
 /

 Execution :- 

 SQL>VARIABLE S VARCHAR2(500)
 SQL>EXECUTE insert_record(1,'A',5000,:S);
 SQL>PRINT :S

 => variable declared at sql prompt are called bind variables and
  bind variables are accessed using : operator.

 Example 4 :- 
 -------------

 ACCOUNTS
 ACCNO    BAL 
 100	  10000
 101	  20000

 create a procedure  for money withdrawl ? 

 CREATE OR REPLACE PROCEDURE debit
 ( 
   p_acno IN accounts.accno%type,
   p_amt  IN number,
   p_bal  OUT accounts.bal%type
 )
 IS
  v_bal accounts.bal%type;
 BEGIN
   SELECT bal INTO v_bal FROM accounts WHERE accno=p_acno;
   IF p_amt > v_bal THEN
     RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
   END IF;
   UPDATE accounts SET bal=bal-p_amt WHERE accno=p_acno;
   COMMIT;
   SELECT bal INTO p_bal FROM accounts WHERE accno=p_acno;
 END;
  /

 Example 5 :- 

  create procedure for money deposit ? 

 Example 6 :- 

  create procedure for money transfer ? 

26-MAR-21 

 PRAGMA AUTONOMOUS_TRANSACTION :- 
 --------------------------------

 => by default oracle will not start seperate transaction for 
    procedure and procedure is always part of the main program.
    so a commit/rollback command in procedure affects  transaction
    started in main program.
   
   CREATE OR REPLACE PROCEDURE increment_sal
   (
     p_eno  IN emp.empno%type
   )
   IS
   BEGIN
     UPDATE emp SET sal=sal+1000 WHERE empno=p_eno;
     ROLLBACK;
   END;
    /

  Main program :- 
  ----------------

   BEGIN
     UPDATE emp SET sal=sal+1000 WHERE empno=7369;
     increment_sal(7499);
     COMMIT;
   END;
    /

 OUTPUT :- 

   7369 update is cancelled (main prog)
   7499 update is cancelled (procedure)

 
 => if procedure created PRAGMA AUTONOMOUS_TRANSACTION then 
    seperate transaction is created for procedure, so a commit/
    rollback command in procedure affects only transaction
    started in procedure but doesn't affect transaction started
    in main prog.

   CREATE OR REPLACE PROCEDURE increment_sal
   (
     p_eno  IN emp.empno%type
   )
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;    
   BEGIN
     UPDATE emp SET sal=sal+1000 WHERE empno=p_eno;
     ROLLBACK;
   END;
    /

   BEGIN
     UPDATE emp SET sal=sal+1000 WHERE empno=7369;
     increment_sal(7499);
     COMMIT;
   END;
    /

 OUTPUT :- 

   7369 UPDATE is committed
   7499 update is cancelled

USER DEFINE FUNCTIONS :-
------------------------

=> functions created by user are called user define functions.
   when predefine functions not meeting our requirements then 
   we create our own functions called user define functions.

=> a function accepts some input performs some calculation and
   must return a value.

=> functions are created for calculations or to fetch value from db
 
=> functions are 2 types 

  1 stored or standalone functions
  2 packaged functions 

stored or standalone functions :- 
--------------------------------

=> these functions are stored as seperate object in database.
=> created with CREATE OR REPLACE command.

 syntax :- 

 CREATE OR REPLACE
    FUNCTION <NAME>(parameters if any) RETURN <type>
 IS
   <declaration-part>;
 BEGIN
    statements;
    RETURN <expr>;
 END;
  /

 Example 1 :- 

 CREATE OR REPLACE 
     FUNCTION CALC(a Number,b Number,op char) RETURN number
 IS
 BEGIN
   IF op='+' THEN
      RETURN(a+b);
   ELSIF op='-' THEN
      RETURN(a-b);
   ELSIF op='*' THEN
      RETURN(a*b);
   ELSE
      RETURN(a/b);
   END IF;
 END;
 /

 function created (stored in db)

Execution :- 
-------------

 1 SQL COMMANDS
 2 another pl/sql programs
 3 front-end applications 

SQL commands :-
---------------

 SELECT CALC(10,20,'*') FROM DUAL ; 
 
another pl/sql program :- 
-------------------------

DECLARE
  x number;
  y number;
  z number;
BEGIN
  x := &x;
  y := &y;
  z := CALC(x,y,'*');
  dbms_output.put_line(z);
 END;
 /

27-mar-21

 create a function to check whether given year is leap year or not ?

 CREATE OR REPLACE 
       FUNCTION IS_LEAP(y number) RETURN VARCHAR2
 IS
   d  date;
 BEGIN
   d :=  TO_DATE('29-FEB-'||y);
   RETURN 'Leap Year';
 EXCEPTION
   WHEN OTHERS THEN
      RETURN 'Not a Leap Year'; 
 END;
  /

Testing :- 

1 SELECT IS_LEAP(2020) FROM DUAL  

2 SELECT IS_LEAP(2021) FROM DUAL ;

Example 3 :- 

PRODUCTS
PRODID	PNAME	PRICE
100	A	500
101	B	200
102	C	400

ORDERS
ORDID	PRODID	QTY
1000	100	3
1000	101	2
1000	102	1
1001	100	2

create a function to calculate total amount of particular order ? 

  input :- ordid = 1000
           output = 2300

 CREATE OR REPLACE  
          FUNCTION getOrdAmt(d number) RETURN number
 IS
  CURSOR C1 IS SELECT o.prodid,o.qty,p.price
               FROM orders o INNER JOIN products p
                 ON o.prodid = p.prodid
               WHERE o.ordid = d;
  t  number := 0;
 BEGIN
   for r in c1
 loop
   t := t + (r.qty*r.price);
 end loop;
   RETURN t;
 END;
 /

function returning records :- 
-----------------------------

=> create a function that returns top N employee list ? 

 CREATE OR REPLACE 
    FUNCTION getTopNEmpList(n  number) RETURN SYS_REFCURSOR
 IS
  c1  SYS_REFCURSOR;
 BEGIN
   open c1 for SELECT *
               FROM (SELECT empno,ename,sal,
                      dense_rank() over (order by sal desc) as rnk
                    FROM emp) E
               WHERE rnk<=n ;
   RETURN c1;
END;
 /

29-mar-21

 what diff b/w procedures & functions ? 

          procedures                          functions 

 1    may o may not returns a value         must return a value 

 2    can return multiple values            always returns one value

 3    returns values using OUT              returns value using
      parameter                              return statement

 4    cannot be called from                  can be called from
      sql commands                           sql commands

 5    created to perform dmls                created for calculations 
                                             or to fetch value from db

 6    create procedure to  update bal         create function to get balance

  is function can contains dml commands ? 

  ans :- yes , but not recommended because if function contains 
   dml commands then it cannot be executed from sql commands 
   must be executed from another pl/sql program.

  is function can be created with OUT parameter ?

  ans :- yes , but not recommended

  is procedure can contain return statement ?

  ans :- yes but a return statement is procedure cannot return value
    returns control to the calling program.

   CREATE OR REPLACE PROCEDURE PROC1
   IS
   BEGIN
     dbms_output.put_line('proc starts');
     RETURN;
     dbms_output.put_line('proc ends');
   END;
    /

   BEGIN
     dbms_output.put_line('main starts');
     proc1;
     dbms_output.put_line('main ends');
   END;
    /

 OUTPUT :-

  main starts
  proc starts
  main ends

USER_SOURCE :-
--------------

=> stores list of procedures & function created by user.

  NAME	 TYPE	LINE	TEXT
  proc1  proc   1       CREATE OR REPLACE PROCEDURE PROC1
                2       IS
                3       BEGIN
                
 display list of procedures & functions ?

  SELECT DISTINCT NAME,TYPE
  FROM USER_SOURCE
  ORDER BY TYPE ASC ; 

 display debit procedure code ? 

  SELECT TEXT
  FROM USER_SOURCE
  WHERE NAME='DEBIT' ;
 
droping procedure :-

  DROP PROCEDURE PROC1 ;

droping function :- 
 
  DROP FUNCTION IS_LEAP ;

PACKAGES :- 
-----------

=> a package is a collection of procedures,functions,variables,
 cursors,types etc.

=> related procedures & functions are grouped into one block called
  package.

=> packages are created 

  1 to group proc & func into one program.
  2 for global declaration.

Advantages :- 
---------------

1 easy to manage :- 

 => because related proc & func are available in single package so
  managing is easy.
 
2 supports overloading :- 
  ----------------------

 => standalone proc & func cannot be overloaded but package
   supports overloading. In package we can define two or more 
   proc & func with same name and with different parameters.

 3  supports hiding :- 
    ------------------

 => by default standalone proc & func are public i.e. they can be
 called from any where but in package we can make members as 
 public and private , public members can be called from any where
 but private members are called with in package.

4  improves performance :-
   ------------------------

 => when application program requests for a member in a package
 then oracle not only loads requested member but the whole package
 loaded into memory and subsequent requests will not go to db. so
 no of requests going to db are reduced and performance is improved.

=> package consists of two parts 

  1 package specification
  2 package body

 package specification :- 
 ------------------------

 => package specification contains declarations of procedures & functions

 CREATE OR REPLACE PACKAGE <NAME>
 AS
 PROCEDURE DECLARATION ;
 FUNCTION DECLARATION ;
 ----------------
 END;
 /

 package body :-
 ----------------

 => package body contains definitions of procedures & functions 

 CREATE OR REPLACE PACKAGE BODY <NAME>
 AS
 PROCEDURE DEFINITION ---;
 FUNCTION DEFINITION ----;
 ------------
 END;
 /


Example :- 

create package to implement following operations ?

1 to hire employee (proc)
2 to fire employee (proc)
3 to update salary (proc)
4 to calculate experience (func)
5 to find top N employees (func)

 CREATE OR REPLACE PACKAGE HR
 AS
 PROCEDURE hire(e number,n varchar2,j varchar2,s number,d number);
 PROCEDURE fire(e number);
 PROCEDURE update_salary(e number,amt number);
 FUNCTION getExpr(e number) RETURN number;
 FUNCTION getTopNEmpList(n number) RETURN SYS_REFCURSOR;
END;
 /

CREATE OR REPLACE PACKAGE BODY HR
AS
PROCEDURE hire(e number,n varchar2,j varchar2,s number,d number)
IS
BEGIN
  INSERT INTO emp(empno,ename,job,sal,hiredate,deptno)
           VALUES(e,n,j,s,sysdate,d);
  COMMIT;
END hire;
PROCEDURE fire(e number)
IS
BEGIN
   DELETE FROM emp WHERE empno=e;
   COMMIT;
END fire;
PROCEDURE update_salary(e number,amt number)
IS
BEGIN
  UPDATE emp SET sal=sal+amt WHERE empno=e;
  COMMIT;
END update_salary;
FUNCTION getExpr(e number) RETURN number
IS
v_expr number(2);
BEGIN
  SELECT (sysdate-hiredate)/365 INTO v_expr 
  FROM emp 
  WHERE empno=e;
  RETURN v_expr;
END getExpr;
FUNCTION getTopNEmpList(n number) RETURN SYS_REFCURSOR
IS
C1 SYS_REFCURSOR;
BEGIN
 OPEN C1 FOR SELECT *
             FROM (SELECT empno,ename,sal,
                          dense_rank() over (order by sal desc) as rnk
                   FROM emp) E
             WHERE rnk<=n;
 RETURN C1;
END getTopNEmpList;
END;
/               

Execution :- 

packagename.member(parameters)

1 EXECUTE HR.update_salary(7369,1000);

2 SELECT HR.getExpr(7369) FROM DUAL ;

3 SELECT HR.getTopNEmpList(5) FROM DUAL  ;

Example 2 :- 

 ACCOUNTS
 ACCNO   NAME   BAL

 TRANSACTIONS
 TRID    TTYPE   TDATE   TAMT     ACCNO

 CREATE SEQUENCE S1
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 99999;

 => create package to implement following bank transactions ?

 1 account opening (proc)
 2 account closing (proc)
 3 money deposit   (proc)
  4 money withdrawl (proc)
 5 money transfer  (proc)
 6 balance enquiry (func)
 7 statement between two given dates (func)
 8 latest N transactions  (func)
 
31-mar-21 :- 

TRIGGERS :- 
-----------

=> a trigger is also a named PL/SQL block like procedure but 
executed implicitly by oracle when user submits DML/DDL commands.

=> TRIGGERS are created 

  1 to control dml/ddl
  2 to enforce complex rules & validations
  3 to audit tables,users,db
  4 to maintain replicas
  5 to generate values for primary key columns

 => TRIGGERS are 3 types 

 1 table level  (dml triggers)
 2 schema level (ddl triggers)
 3 db level     (db triggers)
 
 DML  / TABLE level triggers :- 
 -------------------------------

 => these triggers created on table and executed implicitly when
 user submits dml command to oracle.

  CREATE OR REPLACE TRIGGER <NAME>
  BEFORE/AFTER INSERT OR UPDATE OR DELETE
  ON <TABNAME>
  [FOR EACH ROW]
  [
     DECLARE
        VARIABLES
  ]
  BEGIN
     STATEMENTS
  END;
   /

 BEFORE triggers :- 
 ------------------  fb mobno Accelya@#1122 & Akshay Ak/Lon183@# <-- gm183   gm12<-- Jites28Feb@#  IRCTC LoneAtish13/Jiteh23@#

 => if trigger is before then oracle executes the trigger before
    executing DML.

  1 trigger
  2 dml

 AFTER triggers :- 
 ------------------

 => if trigger is after then oracle executes the trigger after
 executing DML.

 1 dml
 2 trigger

 TRIGGER levels :- 
 --------------------

  1 statemnt level (default)
  2 row level

 => statement level triggers are executed once per the statement.
 => row level triggers are executed once per the row affected by dml.
 
  Examples :- 

  1  create trigger to not to allow dmls on emp table on sunday ?

     CREATE OR REPLACE TRIGGER T1
     BEFORE INSERT OR UPDATE OR DELETE
     ON EMP
     BEGIN
        IF TO_CHAR(SYSDATE,'dy')='sun' THEN
            RAISE_APPLICATION_ERROR(-20001,'sunday dmls are allowed');
        END IF;
     END;
      /

  Testing :- 

   UPDATE emp SET comm=500 WHERE empno=7369 ;  => ERROR

 
 2 create trigger to not to allow dmls on emp table as follows ?

      mon - fri   <10am and >4pm
      sat         <10am and >2pm
      sun         --------------
 
     CREATE OR REPLACE TRIGGER T2
     BEFORE INSERT OR UPDATE OR DELETE
     ON EMP
     BEGIN
        IF TO_CHAR(sysdate,'d') BETWEEN 2 AND 6
           AND
           TO_CHAR(sysdate,'hh24') NOT BETWEEN 10 AND 16 THEN
             RAISE_APPLICATION_ERROR(-20001,'only between 10am and 4pm');
        ELSEIF TO_CHAR(sysdate,'dy')='sat'
              AND
              TO_CHAR(sysdate,'hh24') NOT BETWEEN 10 AND 14 THEN
                 RAISE_APPLICATION_ERROR(-20001,'only between 10am and 2pm');
        ELSIF TO_CHAR(sysdate,'dy')='sun' THEN
             RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
        END IF;
     END;
     /

Testing  :- 

 update emp set sal=3000 where empno=7499; => error

 3  crete trigger to not to allow to update empno ?

     CREATE OR REPLACE TRIGGER T1
     BEFORE UPDATE OF EMPNO
     ON EMP
     BEGIN
        RAISE_APPLICATION_ERROR(-20001,'empno cannot be updated');
     END;
      /
   
01-apr-21

  :new,:old variables :- 
  -----------------------

  => these two variables are called bind variables.
  => these two variables are called rowtype variables. 
  => these variables are allowed in row level triggers but not 
     allowed in statement level triggers.
  => record user is trying to insert is copied to :new variable.
  => record user is trying to delete is copied to :old variable.
  => record user is trying to update is copied to both :old,:new variables.

  example :- 

   INSERT INTO emp VALUES(100,'A','CLERK',5000,--) => :new
                                                      empno ename job 	sal
                                                      100   A     CLERK 5000

   DELETE FROM emp WHERE empno=7499  => :old
                                        empno ename job  	sal
                                        7499  allen salesman	1600

   EMPNO  SAL
   7369   800

   UPDATE emp SET sal=2000 WHERE empno=7369; => :old
                                                 empno  sal
                                                 7369   800

                                                :new
                                                empno  sal
                                                7369   2000

4 create trigger to not to allow to decrement salary ? 

  CREATE OR REPLACE TRIGGER T4
  BEFORE UPDATE 
  ON EMP
  FOR EACH ROW
  BEGIN
     IF :new.sal < :old.sal THEN
           RAISE_APPLICATION_ERROR(-20001,'sal cannot be decremented');
     END IF;
  END;
   /

  Testing :- 

  UPDATE emp SET sal=1000 WHERE empno=7369 ; => ERROR

 5 create trigger to insert details into emp_resign table when employee
   resigns ? 
 
   emp_resign
   empno  ename  hiredate  dor 
  
   CREATE OR REPLACE TRIGGER T5
   AFTER DELETE
   ON EMP
   FOR EACH ROW
   BEGIN
      INSERT INTO emp_resign 
            VALUES(:old.empno,:old.ename,:old.hiredate,SYSDATE);
   END;
    /

Testing :-

     DELETE FROM emp WHERE empno=7369;
  
     SELECT * FROM emp_resign;
 
     empno  ename   hiredate  dor
     7369  smith    17-DEC-80 01-APR-21
  
 
02-apr-21
  
6 create trigger to insert details into emp_audit after performing
  dml on emp ? 

  emp_audit
  uname     operation    optime   new_eno  new_ename new_sal  old_eno  old_ename  old_sal
  batch7am  insert       ???      100      A         5000     NULL     NULL       NULL
  batch7am  update       ???      100      A         6000     100      A          5000
  batch7am  delete       ???      NULL     NULL      NULL     100      A          6000

  CREATE TABLE emp_audit
  (
    uname      varchar2(20),
    operation  varchar2(10),
    optime     timestamp,
    new_eno    number(4),
    new_ename  varchar2(10),
    new_sal    number(7,2),
    old_eno    number(4),
    old_ename  varchar2(10),
    old_sal    number(7,2)
   );

  CREATE OR REPLACE TRIGGER T6
  AFTER INSERT OR UPDATE OR DELETE
  ON EMP
  FOR EACH ROW
  DECLARE
    OP  VARCHAR2(10);
  BEGIN
     IF INSERTING THEN
        OP := 'INSERT';
     ELSIF UPDATING THEN
        OP := 'UPDATE';
     ELSE
       OP := 'DELETE';
     END IF;
     INSERT INTO emp_audit 
        VALUES(user,op,sysdate,:new.empno,:new.ename,:new.sal,
                                :old.empno,:old.ename,:old.sal);
 END;
  /

 how many triggers can be created on table ? 

 ans :- 12

               I 
     B
               U             R
     A
               D             S 
           
 what is the order of execution of triggers ?

 ans :- 
 
 before stmt
 before row
 after row
 after stmt

 COMPOUND TRIGGER :- 
 -------------------

 => introduced in 11g ver.

 => using compound trigger we can define multiple triggers in one trigger.

  CREATE OR REPLACE TRIGGER T7
  FOR UPDATE
  ON emp
  COMPOUND TRIGGER

  BEFORE STATEMENT IS
  BEGIN
    dbms_output.put_line('before stmt');
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
       dbms_output.put_line('before row');
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
      dbms_output.put_line('after row');
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
      dbms_output.put_line('after stmt');
  END AFTER STATEMENT;

END;
 /

 What is mutating table error ? 

 => mutating table errors occurs  in trigger when we try to 
    perform operations on table on which trigger is created.

 create trigger to not to allow more than 4 employees in a dept ? 

 EMP44
 ENO	DNO
 1	10
 2	10
 3	10
 4	10
 5	10 => INVALID

 CREATE OR REPLACE TRIGGER T8
 BEFORE INSERT OR UPDATE
 ON EMP44
 FOR EACH ROW
 DECLARE
    X  NUMBER;
 BEGIN
    SELECT COUNT(*) INTO X FROM EMP44 WHERE DNO=:NEW.DNO;
    IF X=4 THEN
      RAISE_APPLICATION_ERROR(-20001,'max 4 employees per dept');
    END IF;
 END;
 /

   INSERT INTO EMP44 VALUES(1,10);
   INSERT INTO EMP44 VALUES(2,10);
   INSERT INTO EMP44 VALUES(3,10);
   INSERT INTO EMP44 VALUES(4,10);
   INSERT INTO EMP44 VALUES(5,10); => ERROR
   INSERT INTO EMP44 VALUES(5,20); 

   SELECT * FROM EMP44;

   ENO  DNO
   1    10
   2    10
   3    10
   4    10
   5    20

  UPDATE emp44 SET dno=10 WHERE eno=5;

 error :- mutating table error

 => to overcome this problem create trigger with PRAGMA AUTONOMOUS_TRANSACTION.

  CREATE OR REPLACE TRIGGER T8
 BEFORE INSERT OR UPDATE
 ON EMP44
 FOR EACH ROW
 DECLARE
    X  NUMBER;
    PRAGMA AUTONOMOUS_TRANSACTION;
 BEGIN
    SELECT COUNT(*) INTO X FROM EMP44 WHERE DNO=:NEW.DNO;
    IF X=4 THEN
      RAISE_APPLICATION_ERROR(-20001,'max 4 employees per dept');
    END IF;
 END;
 /

 SELECT * FROM EMP44;

   ENO  DNO
   1    10
   2    10
   3    10
   4    10
   5    20

  UPDATE emp44 SET dno=10 WHERE eno=5;

  ERROR :- max 4 employee per dept

03-apr-21

 DDL triggers :- 
 ----------------

 => DDL triggers create on schema and executed implicitly by oracle
 whenever user submits DDL commands.

=> these triggers are created to control DDL operations.

Examples :- 

1 create trigger to not to allow user C##BATCH7AM to drop objects ?

 CREATE OR REPLACE TRIGGER T9
 BEFORE DROP
 ON C##BATCH7AM.SCHEMA
 BEGIN
   RAISE_APPLICATION_ERROR(-20001,'objects cannot be dropped');
 END;
  /

 system variables :- 

1 ora_dict_obj_type
2 ora_dict_obj_name
3 ora_sysevent
4 ora_login_user

2  create trigger to not to allow user C##BATCH7AM to drop tables ?

 CREATE OR REPLACE TRIGGER T9
 BEFORE DROP
 ON C##BATCH7AM.SCHEMA
 BEGIN
   IF ORA_DICT_OBJ_TYPE='TABLE' THEN
     RAISE_APPLICATION_ERROR(-20001,'tables cannot be dropped');
   END IF;
 END;
  /

3 create trigger to not to allow users c##batch7am,c##batch2pm,c##batch4pm  
  to drop tables ?


 CREATE OR REPLACE TRIGGER T9
 BEFORE DROP
 ON DATABASE
 BEGIN
   IF ORA_LOGIN_USER IN ('C##BATCH7AM','C##BATCH2PM','C##BATCH4PM') 
      AND
      ORA_DICT_OBJ_TYPE='TABLE' THEN
         RAISE_APPLICATION_ERROR(-20001,'tables cannot be dropped');
   END IF;
 END;
  /

4 create trigger for ddl auditing ?

  DDL_AUDIT
  UNAME   	OPTIME   OPERATION   OBJ_TYPE   OBJ_NAME
  C##BATCH7AM    ???	 CREATE       TABLE     CUST
  
USER_TRIGGERS :- stores triggers created by user

Droping trigger :-

 DROP TRIGGER T1;

=> if we drop table what about triggers created on table ?

 ans :- triggers are also dropped.

05-apr-21

 Dynamic SQL :- 
 --------------

 => SQL commands build at runtime are called dynamic sql commands.

   ex :-  DROP TABLE emp ; (static sql command)

          
          tname := '&tabname';          
          DROP TABLE tname ; (Dynamic sql command) 

 => Dynamic SQL is useful when we don't know tablenames and column
 names until runtime.

 => use EXECUTE IMMEDIATE to execute DDL commands or Dynamic SQL commands
     
 => DDL or Dynamic SQL command should be passed as a string to EXECUTE IMMEDIATE.

        EXECUTE IMMEDIATE ' Dynamic OR DDL command ' ;

 Example 1 :- 

 create a procedure to drop table ? 

 CREATE OR REPLACE 
    PROCEDURE DROP_TABLE(n varchar2) 
 IS
 BEGIN
   EXECUTE IMMEDIATE ' DROP TABLE '||n;
 END;
  /

Execution :- 

  EXECUTE DROP_TABLE('emp44');
   
Example 2 :- 

 create a procedure to  drop object from db ? 

 CREATE OR REPLACE PROCEDURE DROP_OBJECT
 (
   t varchar2,
   n varchar2
 )
 IS
 BEGIN 
   EXECUTE IMMEDIATE 'DROP '||t||' '||n;
 END;
  /

 Execution :- 

  EXECUTE DROP_OBJECT('TABLE','TEST'); 
  
  EXECUTE DROP_OBJECT('VIEW','TEST_VIEW');
 
=> write a prog to drop all tables from db ? 

  DECLARE
    cursor c1 is select table_name from user_tables;
  BEGIN
    for r in c1
  loop
     EXECUTE IMMEDIATE 'DROP TABLE '||r.table_name;
  end loop;
 END;
  /

=> write a prog to display no of rows in all the tables ?

  emp   ?
  dept  ?
  cust  ? 

  DECLARE
    cursor c1 is select table_name from user_tables;
    s1 varchar2(500);
    cnt number;
  BEGIN
    for r in c1
   loop
     s1 := 'SELECT COUNT(*) FROM '||r.table_name;
     EXECUTE IMMEDIATE s1 INTO cnt;
     dbms_output.put_line(RPAD(r.table_name,20,' ')||' '||cnt);
   end loop;
 END;
  /

---------------------------------------------------------------------

06-apr-21 

utl_file package :- 
-------------------

=> package used to work with files
=> using this package from PL/SQL program we can create files,
   write data and read data from files.

members :-
----------

1 file_type :- it is a datatype
2 fopen     :- it is a function used to open file
3 put_line  :- it is a procedure used to write  data into file
4 get_line  :- it is a procedure used to read data from file
5 flcose    :- it is a procedure used to close file

creating Directory Object :-
----------------------------

=> it is an object in db that points to operating system directory.

=> directory objects are created by DBA and granted to users.

 SYSTEM/manager :-

 CREATE DIRECTORY D1 AS 'E:\VIJAY' 

 GRANT READ,WRITE ON DIRECTORY D1 TO C##BATCH7AM ; 

 program for creating file and writing data :-
 ----------------------------------------------

 DECLARE
   f1  utl_file.file_type ;
 BEGIN
   f1 := utl_file.fopen('D1','abc.txt','w');
   utl_file.put_line(f1,'hello');
   utl_file.put_line(f1,'welcome');
   utl_file.put_line(f1,'utl_file');
   utl_file.fclose(f1);
 END;
  /

reading data from existing file :-
----------------------------------

DECLARE
  f1 utl_file.file_type;
  s  varchar2(500);
BEGIN
  f1 := utl_file.fopen('D1','abc.txt','r');
loop
  utl_file.get_line(f1,s);
  dbms_output.put_line(s);
end loop;
exception
  when no_data_found then
      utl_file.fclose(f1);
end;
 /

copying data from table to flat file :-
----------------------------------------

DECLARE
  f1 utl_file.file_type;
  cursor c1 is select empno,ename,sal,hiredate from emp;
  str  varchar2(500);
BEGIN
  f1 := utl_file.fopen('D1','emp.txt','w');
  for r in c1
 loop
   str := r.empno||','||r.ename||','||r.sal||','||TO_CHAR(r.hiredate,'mm/dd/yyyy');
   utl_file.put_line(f1,str);
 end loop;
 utl_file.fclose(f1);
END;
 /

copying data from table to .CSV file :-
----------------------------------------

DECLARE
  f1 utl_file.file_type;
  cursor c1 is select empno,ename,sal,hiredate from emp;
  str  varchar2(500);
BEGIN
  f1 := utl_file.fopen('D1','emp.csv','w');
  for r in c1
 loop
    str := r.empno||','||r.ename||','||r.sal||','||TO_CHAR(r.hiredate,'mm/dd/yyyy');
     utl_file.put_line(f1,str);
 end loop;
 utl_file.fclose(f1);
END;
 /

copying data from table to xml :- 
----------------------------------

DECLARE 
 f1 utl_file.file_type;
 b  clob;
BEGIN
  f1 := utl_file.fopen('D1','emp.xml','w');
  SELECT 
  DBMS_XMLGEN.GETXML('SELECT empno,ename,sal FROM emp') INTO b
  FROM DUAL;
  utl_file.put(f1,b);
  utl_file.fclose(f1);
END;
 /

07-apr-21

copying data from flat file to oracle table :-
-----------------------------------------------

CREATE TABLE emp22
 (
   empno number(4),
   ename varchar2(10),
   sal   number(7,2),
   hiredate date
 );

DECLARE
  f1     utl_file.file_type;
  s      varchar2(500);
  veno   number(4);
  vename varchar2(10);
  vsal   number(7,2);
  vhire  date;
BEGIN
   f1 := utl_file.fopen('D1','emp.txt','r');
 loop
   utl_file.get_line(f1,s);
   veno   := REGEXP_SUBSTR(s,'[^,]+',1,1);
   vename := REGEXP_SUBSTR(s,'[^,]+',1,2);
   vsal   := REGEXP_SUBSTR(s,'[^,]+',1,3);
   vhire  := TO_DATE(REGEXP_SUBSTR(s,'[^,]+',1,4),'mm/dd/yyyy');
   INSERT INTO emp22 VALUES(veno,vename,vsal,vhire);
 end loop;
 exception
   when no_data_found then
     utl_file.fclose(f1);
     COMMIT;
 end;
 /

---------------------------------------------------------------------

 working with LOBs :- 
 --------------------

 1 BFILE
 2 BLOB 

 => both types are used for storing multimedia objects like audio,
video,images upto 4GB.

 BFILE :- 
 ----------

 => bfile is called external lob because lob stored outside db but
 db stores path called locator.

 => to store locator the following function provided by oracle.

           BFILENAME(dir obj,filename)

 Example :- 

 CREATE TABLE cust
 (
   cid number(2),
   cname varchar2(10),
   cphoto  bfile
 );

 
 INSERT INTO cust VALUES(10,'A',BFILENAME('D1','photo1.jpg'));

 BLOB :- 

 => blob is called internal lob because lob is stored inside db.

 
 
 CREATE TABLE cust
 (
   cid number(2),
   cname varchar2(10),
   cphoto  BLOB
 );

INSERT INTO CUST VALUES(10,'A',EMPTY_BLOB());

create a procedure to update cust photo ?

CREATE OR REPLACE PROCEDURE update_cust_photo
(
   d in number,
   f in varchar2
)
IS
 s  bfile;
 t  blob;
 x  number;
BEGIN
 s :=  BFILENAME('D1',f);
 SELECT cphoto INTO t FROM cust WHERE cid=d FOR UPDATE ; 
 DBMS_LOB.OPEN(s,DBMS_LOB.LOB_READONLY);
 x := DBMS_LOB.GETLENGTH(s);
 DBMS_LOB.LOADFROMFILE(t,s,x);
 UPDATE cust SET cphoto = t WHERE cid=d;
 COMMIT;
 DBMS_LOB.CLOSE(s);
END;
 /

---------------------------------------------------------------------

 collections :- 
 --------------

 => a collection allows group of elements of same datatype and 
    the individual elements are accessed by using index.

 => pl/sql supports 3 types of collections 

  1 index by table or associative array or PL/SQL table
  2 varray
  3 nested table

 Index By Table or Associative Array :- 
 -------------------------------------

 => Index by Table is created with two columns one is index and 
 another one is element.

=> in Index by Table  index can be numeric or char type.

=> to use Index by Table 

  1 declare table type
  2 declare variable

 Declaring Index By Table Type :- 
 --------------------------------

  Type <name> IS TABLE OF <datatype> INDEX BY <datatype>;

 Ex :- 

  Type num_array IS TABLE OF Number(3) INDEX BY BINARY_INTEGER; 

Declaring Variable :- 
----------------------
 
      x   num_array;

      x(1) := 10;
      x(2) := 20;
      x(3) := 30;

      x(10) := 100;

 Example 1 :- 

  DECLARE
   TYPE num_array IS TABLE OF number(3) INDEX BY BINARY_INTEGER;
   x  num_array;
  BEGIN
    for i in 1..10
   loop
     x(i) := i*10;
   end loop;
    for i in 1..10
  loop
    dbms_output.put_line(x(i));
  end loop;
 END;
  /

 Example 2 :- 

 write a prog to print dept names using collection ?

 DECLARE
   TYPE dname_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
   d  dname_array;
 BEGIN
   FOR i in 1..4
 loop
   SELECT dname INTO d(i) FROM dept WHERE deptno=i*10;
 end loop;
  FOR i in 1..4
 loop
   dbms_output.put_line(d(i));
 end loop;
END;
 /

 => in the above example 

 1 select statement is inside a loop , so no of requests going to
   oracle increases and performance degrades.

 2 logic (where deptno=i*10) used to fetch data from dept table will
   work only dept table but not for other tables.

 => to overcome these problems use BULK COLLECT.

BULK COLLECT :- 
---------------

 => using BULK COLLECT in single request we can fetch data from
 server and store that data into collection. so BULK COLLECT
 reduces no of trips to server  and improves performance.

  DECLARE
   TYPE dname_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
   d  dname_array;
  BEGIN
    SELECT dname BULK COLLECT INTO d FROM dept ;
  FOR i in 1..4
  loop
   dbms_output.put_line(d(i));
  end loop;
 END;
  /

 09-apr-21 

 
 DECLARE
   TYPE ename_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
   e  ename_array;
  BEGIN
    SELECT ename BULK COLLECT INTO e FROM emp ;
  FOR i in 1..14
  loop
   dbms_output.put_line(e(i));
  end loop;
 END;
  /

collection methods :-
--------------------

1 first  :- returns index value of the first element
2 last   :- returns index value of the last element
3 next   :- returns index value of the next element
4 prior  :- returns index value of the previous element
5 count  :- returns total no of elements 
6 extend :- to increase the size of collection
7 exists :- to check whether element exists or not
8 delete :- to delete element from collection


 DECLARE
   TYPE ename_array IS TABLE OF VARCHAR2(10) INDEX BY BINARY_INTEGER;
   e  ename_array;
  BEGIN
    SELECT ename BULK COLLECT INTO e FROM emp ;
  FOR i in e.first..e.last
  loop
   dbms_output.put_line(e(i));
  end loop;
 END;
  /

 bulk collecting records :- 
 ---------------------------

 DECLARE
   TYPE emp_array IS TABLE OF emp%rowtype INDEX BY BINARY_INTEGER;
   e  emp_array;
 BEGIN
   SELECT * BULK COLLECT INTO e FROM emp ; 
   FOR i in e.first..e.last
  loop
    dbms_output.put_line(e(i).ename||' '||e(i).sal);
  end loop;
 END;
  /

 e
 1  7369 smith clerk 	800 	null 20
 2  7499 allen salesman 1600 	300  30

 14 

 diff b/w cursor and collection  ?

         cursor                           collection

  1 fetching is row-by-row               all rows are fetched at a time
                                         and stored into collection

  2 gives poor performance              gives good performance 

  3 program consumes less               program consumes more memory
    memory

  4 supports only forward              supports both forward and
    navigation.                        backward navigation 

  5 doesn't supports random            supports random accessing
    accessing

 => write a prog to increment all the employee salaries by 1000
  using collection ? 

   DECLARE
      TYPE empno_array IS TABLE OF NUMBER(4) INDEX BY BINARY_INTEGER;
      e   empno_array;
   BEGIN
      SELECT empno BULK COLLECT INTO e FROM emp;
      FOR i in e.first..e.last
     loop
       UPDATE emp SET sal=sal+1000 WHERE empno=e(i);
     end loop;
       COMMIT;
    END;
     /

 => in the above example every time for loop executes an element
 is passed from pl/sql engine to sql engine and sql engine will
 execute update command and returns control back to pl/sql engine
 and this is called context switch and this degrades performance.
 To improve performance use BULK BIND.

 BULK BIND :- 
 -------------
 
 => BULK BIND reduces no of context switch and improves performance.
 => BULK BIND improves performance of BULK INSERT,BULK UPDATE,BULK DELETE
    operations.
 => to use BULK BIND use FORALL loop instead of FOR loop.

    FORALL <var> IN <low>..<upp>
        DML statement;

 => FORALL loop allows only one statement and it must be DML statement.

 
   DECLARE
      TYPE empno_array IS TABLE OF NUMBER(4) INDEX BY BINARY_INTEGER;
      e   empno_array;
      t1  timestamp;
      t2  timestamp;
   BEGIN
      SELECT empno BULK COLLECT INTO e FROM emp;
      t1 := current_timestamp;
      FORALL i in e.first..e.last
        UPDATE emp SET sal=sal+1000 WHERE empno=e(i);
      t2 := current_timestamp;
      dbms_output.put_line(t2-t1);
      COMMIT;
    END;
     /
 
using procedure :-
---------------------

 CREATE OR REPLACE PACKAGE P1
 AS
 TYPE empno_array IS TABLE OF NUMBER(4) INDEX BY BINARY_INTEGER;
 END;
/


 CREATE OR REPLACE PROCEDURE update_salaries
 (
   e  P1.empno_array
 )
 IS
 BEGIN
   FORALL i in e.first..e.last
      UPDATE emp SET sal=sal+1000 WHERE empno=e(i);
   COMMIT;
 END;
 /

Execution :-
------------

   DECLARE
      e   p1.empno_array;
   BEGIN
      SELECT empno BULK COLLECT INTO e FROM emp;
      update_salaries(e);
    END;
     /
Server Shutdown port No : 8088(Any port no)
 HTTP/1.1 Connector port : 8081 
 User Name : lone
 Password    lone
